{"version":3,"sources":["define.min.js","main.js","keyboard.js","nexus.js","tower.js","Input.js","EditorPlane.js","motor.js","Editor.js","data.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["!function(){function e(e){if(n.hasOwnProperty(e))return n[e]\nthrow'[require-shim] Cannot find module \"'+e+'\"'}function i(i,o,r){var d=null,t=r&&void 0!==r\nif(t){if(r.hasOwnProperty(i))throw\"[define-shim] Module \"+i+\" already exists\"}else if(n.hasOwnProperty(i))throw\"[define-shim] Module \"+i+\" already exists\"\nd=\"function\"==typeof o?o(e):o,t?r[i]=d:n[i]=d}var n={}\nwindow.define=i,window.define.amd=!1,window.require=e}()\n","window.addEventListener('load', function(evt) {\n\tvar data = require('data');\n\tvar tower = require('tower');\n\tvar nexus = require('nexus');\n\tvar keyboard = require('keyboard');\n\tvar motor = require('motor');\n\n\tvar Input = require('Input');\n\tvar EditorPlane = require('EditorPlane');\n\n\tdata.load();\n\tvar map = data.get('map');\n\n\tvar timeTilAutoSave = 200; // timer runs per frame, 60fps\n\tvar saveTimer = 10;\n\tvar dirtyMap = false;\n\tvar shiftDown = false;\n\tvar paintMode = false;\n\tvar deleteMode = false;\n\tvar addMode = false;\n\n\tvar saveBtn = document.getElementById('save-btn');\n\tsaveBtn.onmouseup = function(evt) {\n\t\tsaveMap();\n\t\treturn false;\n\t};\n\n\tvar loadBtn = document.getElementById('load-btn');\n\tloadBtn.addEventListener('click', function() {\n\t\tfileInput.click();\n\t}, false);\n\n\tvar fileInput = document.createElement('input');\n\tfileInput.type = 'file';\n\tfileInput.addEventListener('change', function(evt) {\n\t\tvar file = fileInput.files[0];\n\t\tif (!file) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar reader = new FileReader();\n\t\treader.onload = function(e) {\n\t\t\tvar json = null;\n\t\t\ttry {\n\t\t\t\tjson = JSON.parse(e.target.result);\n\t\t\t}\n\t\t\tcatch(err) {\n\t\t\t\tconsole.warn('File is not json format');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tloadMap(json);\n\t\t};\n\n\t\treader.readAsText(file);\n\n\t\treturn false;\n\t});\n\n\tkeyboard.on();\n\tmotor.on();\n\n\t// setup the thing\n\tvar canvas = document.getElementById('view');\n\tvar scene = new vg.Scene({\n\t\telement: canvas,\n\t\tcameraPosition: {x:0, y:300, z:120}\n\t}, true);\n\n\t// listen to the orbit controls to disable the raycaster while user adjusts the view\n\tscene.controls.addEventListener('wheel', onControlWheel);\n\n\tvar grid = new vg.HexGrid({\n\t\trings: 1,\n\t\tcellSize: 10,\n\t\tcellDepth: 5,\n\t\tcellScale: 0.95\n\t});\n\tvar board = new vg.Board(grid);\n\tvar mouse = new vg.MouseCaster(board.group, scene.camera, canvas);\n\n\tvar input = new Input(board.group, mouse);\n\tvar plane = new EditorPlane(board.group, grid, mouse);\n\n\tnexus.input = input;\n\tnexus.plane = plane;\n\tnexus.board = board;\n\tnexus.grid = grid;\n\tnexus.scene = scene;\n\tnexus.mouse = mouse;\n\n\tvar boardSize = 20; // TODO: get from settings\n\tplane.generatePlane(boardSize * boardSize * 1.8, boardSize * boardSize * 1.8);\n\tboard.generateOverlay(boardSize);\n\tplane.addHoverMeshToGroup(scene.container);\n\n\ttower.tileAction.add(onMapChange, this);\n\n\tscene.add(board.group);\n\tscene.focusOn(board.group);\n\n\tif (map) {\n\t\tloadMap(map);\n\t}\n\telse {\n\t\tvar mapCells = [];\n\t\tvar cell, mat;\n\t\tfor (var c in grid.cells) {\n\t\t\tcell = grid.cells[c];\n\t\t\tmapCells.push({\n\t\t\t\tx: cell.x,\n\t\t\t\ty: cell.y,\n\t\t\t\tz: cell.z,\n\t\t\t\tdepth: cell.w.depth,\n\t\t\t\tmatCacheId: 0,\n\t\t\t\tcustomData: cell.w.userData.mapData\n\t\t\t});\n\t\t}\n\t\tvar mapMats = [];\n\t\tfor (var i = 0; i < grid._matCache.length; i++) {\n\t\t\tmat = grid._matCache[i];\n\t\t\t/*mapMats.push({\n\t\t\t\tcache_id: i,\n\t\t\t\ttype: mat.type,\n\t\t\t\t// color, ambient, emissive, reflectivity, refractionRatio, wrapAround,\n\t\t\t\timgURL: // get this value from the ui\n\t\t\t});*/\n\t\t}\n\t\tmap = {\n\t\t\tcells: mapCells,\n\t\t\tmaterials: mapMats\n\t\t};\n\t\tdata.set('map', map);\n\t\tconsole.log('Created a new map');\n\t}\n\n\tfunction update() {\n\t\tif (wheelTimer < 10) {\n\t\t\twheelTimer++;\n\t\t\tif (wheelTimer === 10) {\n\t\t\t\tmouse.active = true;\n\t\t\t}\n\t\t}\n\t\tif (dirtyMap) {\n\t\t\tsaveTimer--;\n\t\t\tif (saveTimer === 0) {\n\t\t\t\tdirtyMap = false;\n\t\t\t\tdata.save();\n\t\t\t}\n\t\t}\n\t\tmouse.update();\n\t\tinput.update();\n\t\tplane.update();\n\t\tscene.render();\n\t};\n\tmotor.add(update);\n\n\tvar wheelTimer = 10;\n\tfunction onControlWheel() {\n\t\tmouse.active = false;\n\t\twheelTimer = 0;\n\t}\n\n\tfunction onMapChange() {\n\t\tdirtyMap = true;\n\t\tsaveTimer = timeTilAutoSave;\n\t\tmap.cells = grid.toJSON();\n\t}\n\n\tfunction loadMap(json) {\n\t\tboard.group.remove(grid.group);\n\t\tgrid.load(json);\n\t\tboard.setGrid(grid);\n\t\tscene.add(board.group);\n\t\tconsole.log('Map load complete');\n\t}\n\n\tfunction saveMap() {\n\t\tvar output = null;\n\n\t\tmap.cells = grid.toJSON();\n\n\t\ttry {\n\t\t\toutput = JSON.stringify(map, null, '\\t');\n\t\t\toutput = output.replace(/[\\n\\t]+([\\d\\.e\\-\\[\\]]+)/g, '$1');\n\t\t} catch (e) {\n\t\t\toutput = JSON.stringify(map);\n\t\t}\n\n\t\texportString(output, 'hex-map.json');\n\t}\n\n\t// taken from https://github.com/mrdoob/three.js/blob/master/editor/js/Menubar.File.js\n\tvar link = document.createElement('a');\n\tlink.style.display = 'none';\n\tdocument.body.appendChild(link);\n\n\tfunction exportString(output, filename) {\n\t\tvar blob = new Blob([output], {type: 'text/plain'});\n\t\tvar objectURL = URL.createObjectURL(blob);\n\n\t\tlink.href = objectURL;\n\t\tlink.download = filename || 'data.json';\n\t\tlink.target = '_blank';\n\n\t\tvar evt = document.createEvent('MouseEvents');\n\t\tevt.initMouseEvent(\n\t\t\t'click', true, false, window, 0, 0, 0, 0, 0,\n\t\t\tfalse, false, false, false, 0, null\n\t\t);\n\t\tlink.dispatchEvent(evt);\n\t}\n});","define('keyboard', function() {\n\n\tfunction onDown(evt) {\n\t\tswitch (evt.keyCode) {\n\t\t\tcase 16:\n\t\t\t\tk.shift = true;\n\t\t\t\tbreak;\n\t\t\tcase 17:\n\t\t\t\tk.ctrl = true;\n\t\t\t\tbreak;\n\t\t}\n\t\tk.signal.dispatch(k.eventType.DOWN, evt.keyCode);\n\t}\n\n\tfunction onUp(evt) {\n\t\tswitch (evt.keyCode) {\n\t\t\tcase 16:\n\t\t\t\tk.shift = false;\n\t\t\t\tbreak;\n\t\t\tcase 17:\n\t\t\t\tk.ctrl = false;\n\t\t\t\tbreak;\n\t\t}\n\t\tk.signal.dispatch(k.eventType.UP, evt.keyCode);\n\t}\n\n\tvar k = {\n\t\tshift: false,\n\t\tctrl: false,\n\n\t\teventType: {\n\t\t\tDOWN: 'down',\n\t\t\tUP: 'up'\n\t\t},\n\n\t\tsignal: new vg.Signal(),\n\n\t\ton: function() {\n\t\t\tdocument.addEventListener('keydown', onDown, false);\n\t\t\tdocument.addEventListener('keyup', onUp, false);\n\t\t},\n\n\t\toff: function() {\n\t\t\tdocument.removeEventListener('keydown', onDown);\n\t\t\tdocument.removeEventListener('keyup', onUp);\n\t\t},\n\n\t\tcode: {\n\t\t\tA: 'A'.charCodeAt(0),\n\t\t\tB: 'B'.charCodeAt(0),\n\t\t\tC: 'C'.charCodeAt(0),\n\t\t\tD: 'D'.charCodeAt(0),\n\t\t\tE: 'E'.charCodeAt(0),\n\t\t\tF: 'F'.charCodeAt(0),\n\t\t\tG: 'G'.charCodeAt(0),\n\t\t\tH: 'H'.charCodeAt(0),\n\t\t\tI: 'I'.charCodeAt(0),\n\t\t\tJ: 'J'.charCodeAt(0),\n\t\t\tK: 'K'.charCodeAt(0),\n\t\t\tL: 'L'.charCodeAt(0),\n\t\t\tM: 'M'.charCodeAt(0),\n\t\t\tN: 'N'.charCodeAt(0),\n\t\t\tO: 'O'.charCodeAt(0),\n\t\t\tP: 'P'.charCodeAt(0),\n\t\t\tQ: 'Q'.charCodeAt(0),\n\t\t\tR: 'R'.charCodeAt(0),\n\t\t\tS: 'S'.charCodeAt(0),\n\t\t\tT: 'T'.charCodeAt(0),\n\t\t\tU: 'U'.charCodeAt(0),\n\t\t\tV: 'V'.charCodeAt(0),\n\t\t\tW: 'W'.charCodeAt(0),\n\t\t\tX: 'X'.charCodeAt(0),\n\t\t\tY: 'Y'.charCodeAt(0),\n\t\t\tZ: 'Z'.charCodeAt(0),\n\t\t\tZERO: '0'.charCodeAt(0),\n\t\t\tONE: '1'.charCodeAt(0),\n\t\t\tTWO: '2'.charCodeAt(0),\n\t\t\tTHREE: '3'.charCodeAt(0),\n\t\t\tFOUR: '4'.charCodeAt(0),\n\t\t\tFIVE: '5'.charCodeAt(0),\n\t\t\tSIX: '6'.charCodeAt(0),\n\t\t\tSEVEN: '7'.charCodeAt(0),\n\t\t\tEIGHT: '8'.charCodeAt(0),\n\t\t\tNINE: '9'.charCodeAt(0),\n\t\t\tNUMPAD_0: 96,\n\t\t\tNUMPAD_1: 97,\n\t\t\tNUMPAD_2: 98,\n\t\t\tNUMPAD_3: 99,\n\t\t\tNUMPAD_4: 100,\n\t\t\tNUMPAD_5: 101,\n\t\t\tNUMPAD_6: 102,\n\t\t\tNUMPAD_7: 103,\n\t\t\tNUMPAD_8: 104,\n\t\t\tNUMPAD_9: 105,\n\t\t\tNUMPAD_MULTIPLY: 106,\n\t\t\tNUMPAD_ADD: 107,\n\t\t\tNUMPAD_ENTER: 108,\n\t\t\tNUMPAD_SUBTRACT: 109,\n\t\t\tNUMPAD_DECIMAL: 110,\n\t\t\tNUMPAD_DIVIDE: 111,\n\t\t\tF1: 112,\n\t\t\tF2: 113,\n\t\t\tF3: 114,\n\t\t\tF4: 115,\n\t\t\tF5: 116,\n\t\t\tF6: 117,\n\t\t\tF7: 118,\n\t\t\tF8: 119,\n\t\t\tF9: 120,\n\t\t\tF10: 121,\n\t\t\tF11: 122,\n\t\t\tF12: 123,\n\t\t\tF13: 124,\n\t\t\tF14: 125,\n\t\t\tF15: 126,\n\t\t\tCOLON: 186,\n\t\t\tEQUALS: 187,\n\t\t\tUNDERSCORE: 189,\n\t\t\tQUESTION_MARK: 191,\n\t\t\tTILDE: 192,\n\t\t\tOPEN_BRACKET: 219,\n\t\t\tBACKWARD_SLASH: 220,\n\t\t\tCLOSED_BRACKET: 221,\n\t\t\tQUOTES: 222,\n\t\t\tBACKSPACE: 8,\n\t\t\tTAB: 9,\n\t\t\tCLEAR: 12,\n\t\t\tENTER: 13,\n\t\t\tSHIFT: 16,\n\t\t\tCTRL: 17,\n\t\t\tALT: 18,\n\t\t\tCAPS_LOCK: 20,\n\t\t\tESC: 27,\n\t\t\tSPACEBAR: 32,\n\t\t\tPAGE_UP: 33,\n\t\t\tPAGE_DOWN: 34,\n\t\t\tEND: 35,\n\t\t\tHOME: 36,\n\t\t\tLEFT: 37,\n\t\t\tUP: 38,\n\t\t\tRIGHT: 39,\n\t\t\tDOWN: 40,\n\t\t\tINSERT: 45,\n\t\t\tDELETE: 46,\n\t\t\tHELP: 47,\n\t\t\tNUM_LOCK: 144\n\t\t}\n\t};\n\n\treturn k;\n});\n","define('nexus', {\n\tgrid: null,\n\tboard: null,\n\tmouse: null,\n\tscene: null,\n\tinput: null,\n\tplane: null,\n});","define('tower', {\n\ttileAction: new vg.Signal(),\n\tobjAction: new vg.Signal(),\n\tuserAction: new vg.Signal(),\n\n\tsaveMap: new vg.Signal(),\n\tloadMap: new vg.Signal(),\n\n\tCELL_CHANGE_HEIGHT: 'cell.change.height',\n\tCELL_ADD: 'cell.add',\n\tCELL_REMOVE: 'cell.remove',\n});","/*\n\tTranslates the MouseCaster's events into more relevant data that the editor uses.\n*/\ndefine('Input', function() {\n\tvar tower = require('tower');\n\tvar nexus = require('nexus');\n\tvar keyboard = require('keyboard');\n\n\tvar Input = function(scene, mouse) {\n\t\tthis.mouse = mouse;\n\t\tthis.mouse.signal.add(this.onMouse, this);\n\n\t\tthis.mouseDelta = new THREE.Vector3();\n\t\tthis.mousePanMinDistance = 0.1;\n\t\tthis.heightStep = 5;\n\t\tthis.editorWorldPos = new THREE.Vector3(); // current grid position of mouse\n\n\t\tthis.overCell = null;\n\n\t\tthis._travel = 0;\n\n\t\tkeyboard.signal.add(function(type, code) {\n\t\t\tif (type === keyboard.eventType.DOWN) {\n\t\t\t\tif (code === keyboard.code.SHIFT) nexus.scene.controls.enabled = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (code === keyboard.code.SHIFT) nexus.scene.controls.enabled = true;\n\t\t\t}\n\t\t}, this);\n\t};\n\n\tInput.prototype = {\n\t\tupdate: function() {\n\t\t\tvar hit = this.mouse.allHits[0];\n\t\t\tif (hit) {\n\t\t\t\t// flip things around a little to fit to our rotated grid\n\t\t\t\tthis.editorWorldPos.x = hit.point.x;\n\t\t\t\tthis.editorWorldPos.y = -hit.point.z;\n\t\t\t\tthis.editorWorldPos.z = hit.point.y;\n\t\t\t}\n\t\t\tvar dx = this.mouseDelta.x - this.mouse.screenPosition.x;\n\t\t\tvar dy = this.mouseDelta.y - this.mouse.screenPosition.y;\n\t\t\tthis._travel += Math.sqrt(dx * dx + dy * dy);\n\t\t},\n\n\t\tonMouse: function(type, obj) {\n\t\t\tvar hit, cell;\n\t\t\tif (this.mouse.allHits && this.mouse.allHits[0]) {\n\t\t\t\thit = this.mouse.allHits[0];\n\t\t\t}\n\t\t\tswitch (type) {\n\t\t\t\tcase vg.MouseCaster.WHEEL:\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.WHEEL, this.overCell, obj);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vg.MouseCaster.OVER:\n\t\t\t\t\tif (obj) {\n\t\t\t\t\t\tthis.overCell = obj.select();\n\t\t\t\t\t}\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.OVER, this.overCell, hit);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vg.MouseCaster.OUT:\n\t\t\t\t\tif (obj) {\n\t\t\t\t\t\tobj.deselect();\n\t\t\t\t\t\tthis.overCell = null;\n\t\t\t\t\t}\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.OUT, this.overCell, hit);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vg.MouseCaster.DOWN:\n\t\t\t\t\tthis.mouseDelta.copy(this.mouse.screenPosition);\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.DOWN, this.overCell, hit);\n\t\t\t\t\tthis._travel = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vg.MouseCaster.UP:\n\t\t\t\t\tif (this._travel > this.mousePanMinDistance) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.UP, this.overCell, hit);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase vg.MouseCaster.CLICK:\n\t\t\t\t\ttower.userAction.dispatch(vg.MouseCaster.CLICK, this.overCell, hit);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn Input;\n});\n","/*\r\n\t2D plane that the user moves mouse around on in order to build maps. Provides a working plane to navigate, and a visual aid for tile placement.\r\n */\r\ndefine('EditorPlane', function() {\r\n\r\n\tfunction EditorPlane(scene, grid, mouse) {\r\n\t\tthis.nexus = require('nexus');\r\n\t\tthis.tower = require('tower');\r\n\r\n\t\tthis.geometry = null;\r\n\t\tthis.mesh = null;\r\n\t\tthis.material = new THREE.MeshBasicMaterial({\r\n\t\t\tcolor: 0xffffff,\r\n\t\t\tside: THREE.DoubleSide\r\n\t\t});\r\n\r\n\t\tthis.scene = scene;\r\n\t\tthis.grid = grid;\r\n\r\n\t\tthis.hoverMesh = this.grid.generateTilePoly(new THREE.MeshBasicMaterial({\r\n\t\t\tcolor: 0x1aaeff,\r\n\t\t\t// transparent: true,\r\n\t\t\t// opacity: 0.5,\r\n\t\t\t// emissive: new THREE.Color(0xffe419),\r\n\t\t\tside: THREE.DoubleSide\r\n\t\t}));\r\n\r\n\t\tthis.mouse = mouse;\r\n\r\n\t\t/*this.mouse.signal.add(onUserAction, this);\r\n\t\tfunction onUserAction(type, overCell) {\r\n\t\t\tswitch (type) {\r\n\t\t\t\tcase vg.MouseCaster.OVER:\r\n\t\t\t\t\tif (overCell) {\r\n\t\t\t\t\t\tthis.hoverMesh.mesh.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase vg.MouseCaster.OUT:\r\n\t\t\t\t\tthis.hoverMesh.mesh.visible = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase vg.MouseCaster.DOWN:\r\n\t\t\t\t\tthis.hoverMesh.mesh.visible = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase vg.MouseCaster.UP:\r\n\t\t\t\t\tif (!overCell) {\r\n\t\t\t\t\t\tthis.hoverMesh.mesh.visible = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.hoverMesh.mesh.visible = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}*/\r\n\t}\r\n\r\n\tEditorPlane.prototype = {\r\n\r\n\t\tgeneratePlane: function(width, height) {\r\n\t\t\tif (this.mesh && this.mesh.parent) {\r\n\t\t\t\tthis.mesh.parent.remove(this.mesh);\r\n\t\t\t}\r\n\t\t\tthis.geometry = new THREE.PlaneBufferGeometry(width, width, 1, 1);\r\n\t\t\tthis.mesh = new THREE.Mesh(this.geometry, this.material);\r\n\t\t\tthis.mesh.rotation.x = 90 * vg.DEG_TO_RAD;\r\n\t\t\tthis.mesh.position.y -= 0.1;\r\n\t\t\tthis.scene.add(this.mesh);\r\n\t\t},\r\n\r\n\t\t//http://stackoverflow.com/questions/20734438/algorithm-to-generate-a-hexagonal-grid-with-coordinate-system\r\n\t\t// http://www.redblobgames.com/grids/hexagons/implementation.html\r\n\t\t/*generateHexGrid: function(Graphics g, Point origin, int size, int radius, int padding) {\r\n\t\t\tdouble ang30 = Math.toRadians(30);\r\n\t\t\tdouble xOff = Math.cos(ang30) * (radius + padding);\r\n\t\t\tdouble yOff = Math.sin(ang30) * (radius + padding);\r\n\t\t\tint half = size / 2;\r\n\r\n\t\t\tfor (int row = 0; row < size; row++) {\r\n\t\t\t\tint cols = size - java.lang.Math.abs(row - half);\r\n\r\n\t\t\t\tfor (int col = 0; col < cols; col++) {\r\n\t\t\t\t\tint xLbl = row < half ? col - row : col - half;\r\n\t\t\t\t\tint yLbl = row - half;\r\n\t\t\t\t\tint x = (int) (origin.x + xOff * (col * 2 + 1 - cols));\r\n\t\t\t\t\tint y = (int) (origin.y + yOff * (row - half) * 3);\r\n\r\n\t\t\t\t\tdrawHex(g, xLbl, yLbl, x, y, radius);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},*/\r\n\r\n\t\taddHoverMeshToGroup: function(group) {\r\n\t\t\tif (this.hoverMesh.parent) {\r\n\t\t\t\tthis.hoverMesh.parent.remove(this.hoverMesh);\r\n\t\t\t}\r\n\t\t\tgroup.add(this.hoverMesh);\r\n\t\t},\r\n\r\n\t\tupdate: function() {\r\n\t\t\tif (this.mouse.allHits.length && !this.mouse.pickedObject) {\r\n\t\t\t\tthis.grid.setPositionToCell(this.hoverMesh.position, this.grid.pixelToCell(this.nexus.input.editorWorldPos));\r\n\t\t\t\tthis.hoverMesh.position.y += 0.1;\r\n\t\t\t\tthis.hoverMesh.visible = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.hoverMesh.visible = false;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\treturn EditorPlane;\r\n});\r\n","/*\n\tThis is the ONLY place in the app that has a requestAnimationFrame handler.\n\tAll modules attach their functions to this module if they want in on the RAF.\n */\ndefine('motor', function() {\n\tvar _brake = false;\n\tvar _steps = [];\n\n\tfunction on() {\n\t\t_brake = false;\n\t\twindow.requestAnimationFrame(_update);\n\t\twindow.addEventListener('focus', onFocus, false);\n\t\twindow.addEventListener('blur', onBlur, false);\n\t}\n\n\tfunction off() {\n\t\t_brake = true;\n\t\twindow.removeEventListener('focus', onFocus, false);\n\t\twindow.removeEventListener('blur', onBlur, false);\n\t}\n\n\t// in order to be able to ID functions we have to hash them to generate unique-ish keys for us to find them with later\n\t// if we don't do this, we won't be able to remove callbacks that were bound and save us from binding callbacks multiple times all over the place\n\tfunction add(cb, scope) {\n\t\tvar k = _hashStr(cb.toString());\n\t\tvar h = _has(k);\n\t\tif (h === -1) {\n\t\t\t_steps.push({\n\t\t\t\tfunc: cb,\n\t\t\t\tscope: scope,\n\t\t\t\tkey: k\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction remove(cb) {\n\t\tvar k = _hashStr(cb.toString());\n\t\tvar i = _has(k);\n\t\tif (i !== -1) {\n\t\t\t_steps.splice(i, 1);\n\t\t}\n\t}\n\n\tfunction _update() {\n\t\tif (_brake) return;\n\t\twindow.requestAnimationFrame(_update);\n\n\t\tfor (var i = 0; i < _steps.length; i++) {\n\t\t\tvar o = _steps[i];\n\t\t\to.func.call(o.scope || null);\n\t\t}\n\t}\n\n\t// check if the handler already has iaw.motor particular callback\n\tfunction _has(k) {\n\t\tvar n = -1;\n\t\tvar i;\n\t\tfor (i = 0; i < _steps.length; i++) {\n\t\t\tn = _steps[i].key;\n\t\t\tif (n === k) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tfunction onFocus(evt) {\n\t\t_brake = false;\n\t\t_update();\n\t}\n\n\tfunction onBlur(evt) {\n\t\t_brake = true;\n\t}\n\n\tfunction _hashStr(str) {\n\t\tvar hash = 0, i, chr, len;\n\t\tif (str.length === 0) return hash;\n\t\tfor (i = 0, len = str.length; i < len; i++) {\n\t\t\tchr = str.charCodeAt(i);\n\t\t\thash = ((hash << 5) - hash) + chr;\n\t\t\thash |= 0;\n\t\t}\n\t\treturn hash;\n\t}\n\n\treturn {\n\t\ton: on,\n\t\toff: off,\n\t\tadd: add,\n\t\tremove: remove,\n\t}\n});\n","/*\n\tManages cells and objects on the map.\n*/\ndefine('Editor', function() {\n\tvar tower = require('tower');\n\tvar nexus = require('nexus');\n\tvar keyboard = require('keyboard');\n\tvar motor = require('motor');\n\n\t// TODO: get these values from UI\n\tvar heightStep = 5;\n\n\t// PRIVATE\n\tvar lastHeight = 5;\n\tvar currentGridCell = null;\n\tvar prevGridCell = new THREE.Vector3();\n\n\ttower.userAction.add(onUserAction, this);\n\tmotor.add(update);\n\n\tfunction update() {\n\t\tcurrentGridCell = nexus.grid.pixelToCell(nexus.input.editorWorldPos);\n\t\tif (nexus.mouse.down && keyboard.shift && nexus.mouse.allHits && nexus.mouse.allHits.length) {\n\t\t\t// only check if the user's mouse is over the editor plane\n\t\t\tif (!currentGridCell.equals(prevGridCell)) {\n\t\t\t\taddTile();\n\t\t\t}\n\t\t\tprevGridCell.copy(currentGridCell);\n\t\t}\n\t}\n\n\tfunction onUserAction(type, overCell, data) {\n\t\tvar hit = nexus.mouse.allHits[0]\n\t\tvar cell;\n\t\tswitch (type) {\n\t\t\tcase vg.MouseCaster.WHEEL:\n\t\t\t\tif (keyboard.shift && overCell) {\n\t\t\t\t\tvar gridPos = overCell.gridPos;\n\t\t\t\t\tnexus.grid.remove(overCell);\n\n\t\t\t\t\tvar dif = lastHeight - data;\n\t\t\t\t\tnexus.mouse.wheel = (overCell.depth / heightStep) + (dif > 0 ? -1 : 1);\n\n\t\t\t\t\tcell = nexus.grid.generateTile(nexus.mouse.wheel * heightStep);\n\t\t\t\t\tnexus.grid.add(gridPos, cell);\n\t\t\t\t\tlastHeight = nexus.mouse.wheel;\n\n\t\t\t\t\toverCell = cell;\n\n\t\t\t\t\ttower.tileAction.dispatch(tower.CELL_CHANGE_HEIGHT, cell, heightStep);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase vg.MouseCaster.OVER:\n\t\t\t\tif (keyboard.shift) {\n\t\t\t\t\tif (overCell && nexus.mouse.rightDown) {\n\t\t\t\t\t\tremoveTile(overCell);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!overCell && nexus.mouse.down) {\n\t\t\t\t\t\taddTile();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase vg.MouseCaster.OUT:\n\n\t\t\t\tbreak;\n\n\t\t\tcase vg.MouseCaster.DOWN:\n\t\t\t\tif (keyboard.shift && nexus.mouse.down && data && !overCell) {\n\t\t\t\t\t// if shift is down then she's painting, so add a cell immediately\n\t\t\t\t\taddTile();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase vg.MouseCaster.UP:\n\t\t\t\tif (nexus.mouse.down && data && !overCell) {\n\t\t\t\t\t// create a new cell, if one isn't already there\n\t\t\t\t\taddTile();\n\t\t\t\t}\n\t\t\t\telse if (nexus.mouse.rightDown && overCell) {\n\t\t\t\t\t// remove a cell if it's there and right mouse is down\n\t\t\t\t\tremoveTile(overCell);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tfunction addTile() {\n\t\tif (!currentGridCell || nexus.grid.getTileAtCell(currentGridCell)) return;\n\t\tnexus.mouse.wheel = lastHeight;\n\t\tvar cell = nexus.grid.generateTile(nexus.mouse.wheel * heightStep);\n\t\tnexus.grid.add(currentGridCell, cell);\n\n\t\ttower.tileAction.dispatch(tower.CELL_ADD, cell, heightStep);\n\t}\n\n\tfunction removeTile(overCell) {\n\t\tnexus.grid.remove(overCell);\n\n\t\ttower.tileAction.dispatch(tower.CELL_REMOVE, overCell);\n\t}\n\n\t/*document.oncontextmenu = function() {\n\t\treturn false;\n\t};*/\n\n\treturn {\n\n\t}\n});","/*\n\tHandles JSON for whatever data needs to be saved to localStorage, and provides a convenient signal for whenever that data changes.\n*/\ndefine('data', {\n\t_store: {},\n\tchanged: new vg.Signal(),\n\n\tget: function(key) {\n\t\treturn this._store[key] || null;\n\t},\n\n\tset: function(key, val) {\n\t\t// fire event first so we can retrieve old data before it's overwritten (just in case)\n\t\tthis.changed.dispatch(key, this._store[key], val);\n\t\tthis._store[key] = val;\n\t},\n\n\tsave: function() {\n\t\twindow.localStorage['vongrid'] = JSON.stringify(this._store);\n\t},\n\n\tload: function(json) {\n\t\tvar data = window.localStorage['vongrid'];\n\t\tif (json || data) {\n\t\t\ttry {\n\t\t\t\tthis._store = json || JSON.parse(data);\n\t\t\t\tthis.changed.dispatch('load-success');\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tconsole.warn('Error loading editor data');\n\t\t\t\tthis.changed.dispatch('load-failure');\n\t\t\t}\n\t\t}\n\t}\n});"],"sourceRoot":"/source/"}