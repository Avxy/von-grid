/*
	Manages cells and objects on the map.
*/
define('toolbag', function() {
	var tower = require('tower');
	var nexus = require('nexus');
	var keyboard = require('keyboard');
	var motor = require('motor');

	var addTile = require('addTile');
	var removeTile = require('removeTile');

	var tool = addTile; // should be the first tool in the bag as determined by tool-menu.tag

	var heightStep = 3;
	var lastHeight = 1;
	var currentGridCell = null;
	var prevGridCell = new THREE.Vector3();
	var _cel = new vg.Cell();

	tower.userAction.add(onUserAction, this);
	ui.on(ui.Events.TOOL_CHANGE, toolChange);

	motor.add(update);

	function update() {
		currentGridCell = nexus.grid.pixelToCell(nexus.input.editorWorldPos);
		if (!keyboard.ctrl && nexus.mouse.down && ui.activeTool.name === 'ADD_TILE' && nexus.mouse.allHits && nexus.mouse.allHits.length) {
			// special case since the over event doesn't fire if there's no tile
			if (!currentGridCell.equals(prevGridCell)) {
				addTile.action(currentGridCell, null);
			}
			prevGridCell.copy(currentGridCell);
		}
	}

	function toolChange(evt) {
		switch (evt) {
			case ui.Tools.ADD_TILE:
				tool = addTile;
				break;
			case ui.Tools.REMOVE_TILE:
				tool = removeTile;
				break;
		}
	}

	function onUserAction(type, overTile, data) {
		// var hit = nexus.mouse.allHits[0];
		if (keyboard.ctrl || data === null || nexus.mouse.rightDown || !tool) {
			// there's no picked object, which means the user isn't hovering over any mesh in the scene
			// also ignore right-mouse clicks
			return;
		}
		switch (type) {
			case vg.MouseCaster.WHEEL:
				nexus.scene.controls.enabled = false;
				if (keyboard.shift && overTile && nexus.grid.autogenerated) {
					if (!overTile.cell) {
						overTile.dispose();
						return;
					}
					_cel.copy(overTile.cell);
					_cel.tile = null;

					var dif = lastHeight - data;
					var last = _cel.h;
					_cel.h += dif > 0 ? -heightStep : heightStep;
					if (_cel.h < 1) _cel.h = 1;

					nexus.mouse.wheel = Math.round((_cel.h / heightStep) + (dif > 0 ? -1 : 1));
					lastHeight = nexus.mouse.wheel;

					if (last === _cel.h) return;
					removeTile.action(overTile);

					var tile = addTile.action(_cel);
					tile.select();

					tower.tileAction.dispatch(tower.TILE_CHANGE_HEIGHT, tile);
				}
				break;

			case vg.MouseCaster.OVER:
				tool.onOver(currentGridCell, overTile, data);
				/*if (keyboard.shift) {
					if (overTile && nexus.mouse.rightDown) {
						removeTile(overTile);
					}
					else if (!overTile && nexus.mouse.down) {
						addTile(currentGridCell);
					}
				}*/
				break;

			case vg.MouseCaster.OUT:

				break;

			case vg.MouseCaster.DOWN:
				/*if (keyboard.shift && nexus.mouse.down && data && !overTile) {
					// if shift is down then they're painting, so add a tile immediately
					addTile(currentGridCell);
				}*/
				tool.onDown(currentGridCell, overTile, data);
				break;

			case vg.MouseCaster.UP:
				/*if (nexus.mouse.down && data && !overTile) {
					// create a new tile, if one isn't already there
					addTile(currentGridCell);
				}
				else if (nexus.mouse.rightDown && overTile) {
					// remove a tile if it's there and right mouse is down
					removeTile(overTile);
				}*/
				tool.onUp(currentGridCell, overTile, data);
				break;
		}
	}

	return {

	}
});