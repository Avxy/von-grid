<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv='X-UA-Compatible' content='IE=edge' />
	<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0' />
	<meta name="author" content="Corey Birnbaum" />
	<title>Grid</title>
	
	<link href="../css/normalize.css" rel="stylesheet" type="text/css"/>
	<style>
		body {
			overflow: hidden;
		}
		#view {
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>

<body>
	
	<div id="view"></div>
	

<script type="text/javascript" src="../js/lib/three.min.js"></script>
<!-- <script type="text/javascript" src="../js/lib/OrbitControls.js"></script> -->
<script type="text/javascript" src="../js/lib/require.js"></script>
<script type="text/javascript">
requirejs.config({
	baseUrl: '../js'
});
requirejs(['graphs/HexGrid', 'graphs/SquareGrid', 'Board', 'Scene', 'MouseCaster', '../extras/Sprite', 'SelectionManager', 'Tools'],
function(HexGrid, SquareGrid, Board, Scene, MouseCaster, Sprite, SelectionManager, Tools) {
	// setup the thing
	var scene = new Scene({
		element: document.getElementById('view'),
		cameraType: 'OrthographicCamera',
		cameraPosition: {x:0, y:200, z:0}
	}, false);
	
	var grid = new HexGrid({
		rings: 4,
		cellSize: 10,
		cellScale: 0.95
	});
	/*var grid = new SquareGrid({
		width: 8,
		height: 8,
		cellSize: 15,
		cellScale: 0.95
	});*/
	
	var mouse = new MouseCaster(scene.container, scene.camera);
	// we only want to scan while the mouse is held down
	mouse.active = false;
	
	var board = new Board(grid, {
		
	});
	
	scene.add(board.group);
	scene.focusOn(board.group);
	
	// populate the board
	var spriteConfig = {
		container: board.group,
		url: '../img/water.png',
		scale: 10,
		offsetY: 6
	};
	
	var startSprite = new Sprite(spriteConfig);
	startSprite.activate();
	board.placeEntityAtCell(startSprite, board.getRandomCell());
	
	spriteConfig.url = '../img/fire.png'
	var endSprite = new Sprite(spriteConfig);
	endSprite.activate();
	board.placeEntityAtCell(endSprite, board.getRandomCell());
	
	// path markers
	spriteConfig.url = '../img/marker.png'
	spriteConfig.scale = 7;
	var markers = [];
	for (var i = 0; i < 20; i++) {
		markers[i] = new Sprite(spriteConfig);
	}
	
	// keep track of states
	var movingPiece = null;
	var lastCell = null;
	
	// handle interaction
	mouse.signal.add(function(type, obj) {
		switch (type) {
			case MouseCaster.DOWN:
				// force an update to get latest data
				mouse.active = true;
				mouse.update();
				obj = mouse.pickedObject;
				// "pick up" the piece we selected, if any
				movingPiece = obj;
				if (obj && obj.objectType === Board.Cell) {
					movingPiece = obj.entity;
					lastCell = obj;
				}
				
				if (movingPiece) {
					// since we're moving the path around again, clear the old one visually
					clearMarkers();
					// grid.traverse(clearCell);
					
					if (movingPiece.objectType === Board.Entity) {
						lastCell = movingPiece.cell;
					}
				}
				break;
				
			case MouseCaster.UP:
				// disable the mouse until the user clicks again
				mouse.active = false;
				if (movingPiece) {
					// user was moving a piece around, so place it at the nearest cell
					var c = findCellUnderMouse();
					board.placeEntityAtCell(movingPiece, c || lastCell);
					// now re-run the pathfinder
					var path = board.findPath(startSprite.cell, endSprite.cell);
					// highlight the path
					if (path) {
						var m;
						for (var i = 0; i < path.length; i++) {
							m = markers[i];
							if (!m) {
								// just in case
								m = markers[i] = new Sprite(spriteConfig);
							}
							m.activate();
							board.placeEntityAtCell(m, path[i]);
						}
					}
				}
				movingPiece = null;
				break;
		}
	}, this);
	
	/*selector.onSelect.add(function(obj) {
		if (obj.objectType === Board.Cell) {
			// select the sprite if one was there
			var e = obj.entity;
			if (e) {
				selector.select(e, false); // don't fire the signal when overriding or you'll cause a stack overflow with recursion
				movingPiece = e; // new move
			}
			else {
				selector.clearSelection(false);
				if (movingPiece) {
					moveEntityToCell(obj);
					return;
				}
				board.placeEntityAtCell(endSprite, obj);
			}
		}
		else {
			movingPiece = obj;
		}
	}, this);*/

	function findCellUnderMouse() {
		var i, c;
		var objects = mouse.allObjects;
		for (i = 0; i < objects.length; i++) {
			c = objects[i].object.userData.structure;
			if (c && c.objectType && c.objectType === Board.Cell) {
				return c;
			}
		}
		return null;
	}
	
	function clearCell(c) {
		if (c.selected) {
			c.deselect();
		}
	}
	
	function clearMarkers() {
		var i;
		for (i = 0; i < markers.length; i++) {
			markers[i].disable();
		}
	}
	
	// start the thing
	update();
	function update() {
		mouse.update();
		if (movingPiece) {
			movingPiece.position.copy(mouse.position);
			movingPiece.position.y = movingPiece.offsetY;
		}
		scene.updateOrthoZoom();
		scene.render();
		requestAnimationFrame(update);
	}
	
	function onMouseWheel(evt) {
		evt.preventDefault();
		evt.stopPropagation();
		var delta = 0;
		if (evt.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9
			delta = evt.wheelDelta;
		}
		else if (evt.detail !== undefined) { // Firefox
			delta = -evt.detail;
		}
		if (delta > 0) {
			scene.orthoZoom++;
		}
		else {
			scene.orthoZoom--;
		}
	}
	document.addEventListener('mousewheel', onMouseWheel, false );
	document.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
});
</script>
</body>
</html>
