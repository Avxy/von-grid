(function(THREE) {
define({
  PI: Math.PI,
  TAU: Math.PI * 2,
  DEG_TO_RAD: 0.0174532925,
  RAD_TO_DEG: 57.2957795,
  clamp: function (val, min, max) {
    return Math.max(min, Math.min(max, val));
  },
  sign: function (val) {
    return val && val / Math.abs(val);
  },
  /**
  * If one value is passed, it will return something from -val to val.
  * Else it returns a value between the range specified by min, max.
  */
  random: function (min, max) {
    if (arguments.length === 1) {
      return Math.random() * min - min * 0.5;
    }
    return Math.random() * (max - min) + min;
  },
  // from min to (and including) max
  randomInt: function (min, max) {
    if (arguments.length === 1) {
      return Math.random() * min - min * 0.5 | 0;
    }
    return Math.random() * (max - min + 1) + min | 0;
  },
  normalize: function (v, min, max) {
    return (v - min) / (max - min);
  },
  getShortRotation: function (angle) {
    angle %= this.TAU;
    if (angle > this.PI) {
      angle -= this.TAU;
    } else if (angle < -this.PI) {
      angle += this.TAU;
    }
    return angle;
  },
  generateID: function () {
    return Math.random().toString(36).slice(2) + Date.now();
  },
  isPlainObject: function (obj) {
    // Not plain objects:
    // - Any object or value whose internal [[Class]] property is not '[object Object]'
    // - DOM nodes
    // - window
    if (typeof obj !== 'object' || obj.nodeType || obj === obj.window) {
      return false;
    }
    // Support: Firefox <20
    // The try/catch suppresses exceptions thrown when attempting to access
    // the 'constructor' property of certain host objects, ie. |window.location|
    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622
    try {
      if (obj.constructor && !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
      }
    } catch (e) {
      return false;
    }
    // If the function hasn't returned already, we're confident that
    // |obj| is a plain object, created by {} or constructed with new Object
    return true;
  },
  merge: function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    }
    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) !== null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];
          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }
          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (this.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && this.isPlainObject(src) ? src : {};
            }
            // Never move original objects, clone them
            target[name] = this.merge(deep, clone, copy);
          } else if (copy !== undefined) {
            // Don't bring in undefined values
            target[name] = copy;
          }
        }
      }
    }
    // Return the modified object
    return target;
  },
  now: function () {
    return window.nwf ? window.nwf.system.Performance.elapsedTime : window.performance.now();
  },
  empty: function (node) {
    while (node.lastChild) {
      node.removeChild(node.lastChild);
    }
  },
  /*
  @source: http://jsperf.com/radix-sort
  */
  radixSort: function (arr, idx_begin, idx_end, bit) {
    idx_begin = idx_begin || 0;
    idx_end = idx_end || arr.length;
    bit = bit || 31;
    if (idx_begin >= idx_end - 1 || bit < 0) {
      return;
    }
    var idx = idx_begin;
    var idx_ones = idx_end;
    var mask = 1 << bit;
    while (idx < idx_ones) {
      if (arr[idx] & mask) {
        --idx_ones;
        var tmp = arr[idx];
        arr[idx] = arr[idx_ones];
        arr[idx_ones] = tmp;
      } else {
        ++idx;
      }
    }
    this.radixSort(arr, idx_begin, idx_ones, bit - 1);
    this.radixSort(arr, idx_ones, idx_end, bit - 1);
  },
  randomizeRGB: function (base, range) {
    var rgb = base.split(',');
    var color = 'rgb(';
    var i, c;
    range = this.randomInt(range);
    for (i = 0; i < 3; i++) {
      c = parseInt(rgb[i]) + range;
      if (c < 0)
        c = 0;
      else if (c > 255)
        c = 255;
      color += c + ',';
    }
    color = color.substring(0, color.length - 1);
    color += ')';
    return color;
  },
  getJSON: function (url, callback, scope) {
    var xhr;
    if (typeof XMLHttpRequest !== 'undefined') {
      xhr = new XMLHttpRequest();
    } else {
      var versions = [
        'MSXML2.XmlHttp.5.0',
        'MSXML2.XmlHttp.4.0',
        'MSXML2.XmlHttp.3.0',
        'MSXML2.XmlHttp.2.0',
        'Microsoft.XmlHttp'
      ];
      for (var i = 0, len = versions.length; i < len; i++) {
        try {
          xhr = new ActiveXObject(versions[i]);
          break;
        } catch (err) {
        }
      }
    }
    xhr.onreadystatechange = function () {
      if (this.readyState < 4 || this.status !== 200) {
        console.warn('[Tools] Error - ' + this.statusText + ' - loading ' + url);
        return;
      }
      callback.call(scope || this, JSON.parse(this.responseText));
    };
    xhr.open('GET', url, true);
    xhr.send('');
  }
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	
 */
define([
  'utils/Tools',
  'lib/LinkedList',
  'utils/MouseCaster',
  'lib/Signal'
], function (Tools, LinkedList, MouseCaster, Signal) {
  var SelectionManager = function (mouse) {
    this.mouse = mouse;
    this.onSelect = new Signal();
    this.onDeselect = new Signal();
    this.selected = null;
    // deselect if player clicked on the same thing twice
    this.toggleSelection = false;
    // allow multiple entities to be selected at once
    // this.multiselect = false; // todo
    // this.allSelected = new LinkedList();
    this.mouse.signal.add(this.onMouse, this);
  };
  SelectionManager.prototype = {
    select: function (obj, fireSignal) {
      if (!obj)
        return;
      fireSignal = fireSignal || true;
      if (this.selected !== obj) {
        // deselect previous object
        this.clearSelection(fireSignal);
      }
      if (obj.selected) {
        if (this.toggleSelection) {
          if (fireSignal) {
            this.onDeselect.dispatch(obj);
          }
          obj.deselect();
        }
      } else {
        obj.select();
      }
      this.selected = obj;
      if (fireSignal) {
        this.onSelect.dispatch(obj);
      }
    },
    clearSelection: function (fireSignal) {
      fireSignal = fireSignal || true;
      if (this.selected) {
        if (fireSignal) {
          this.onDeselect.dispatch(this.selected);
        }
        this.selected.deselect();
      }
      this.selected = null;
    },
    onMouse: function (type, obj) {
      switch (type) {
      case MouseCaster.DOWN:
        if (!obj) {
          this.clearSelection();
        }
        break;
      case MouseCaster.CLICK:
        this.select(obj);
        break;
      }
    }
  };
  return SelectionManager;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define(['utils/Tools'], function (Tools) {
  /*
  	Sets up and manages a THREEjs container, camera, and light, making it easy to get going.
  	Also provides camera control.
  
  	Assumes full screen.
   */
  var Scene = function (sceneConfig, controlConfig) {
    var sceneSettings = {
      element: document.body,
      alpha: true,
      antialias: true,
      clearColor: '#fff',
      sortObjects: false,
      fog: null,
      light: new THREE.DirectionalLight(16777215),
      lightPosition: null,
      cameraType: 'PerspectiveCamera',
      cameraPosition: null  // {x, y, z}
    };
    var controlSettings = {
      minDistance: 100,
      maxDistance: 1000,
      zoomSpeed: 2,
      noZoom: false
    };
    Tools.merge(sceneSettings, sceneConfig);
    Tools.merge(controlSettings, controlConfig);
    this.renderer = new THREE.WebGLRenderer({
      alpha: sceneSettings.alpha,
      antialias: sceneSettings.antialias
    });
    this.renderer.setClearColor(sceneSettings.clearColor, 0);
    this.renderer.sortObjects = sceneSettings.sortObjects;
    this.width = window.innerWidth;
    this.height = window.innerHeight;
    this.orthoZoom = 4;
    this.container = new THREE.Scene();
    this.container.fog = sceneSettings.fog;
    this.container.add(new THREE.AmbientLight(14540253));
    if (!sceneSettings.lightPosition) {
      sceneSettings.light.position.set(-1, 1, -1).normalize();
    }
    this.container.add(sceneSettings.light);
    if (sceneSettings.cameraType === 'OrthographicCamera') {
      var width = window.innerWidth / this.orthoZoom;
      var height = window.innerHeight / this.orthoZoom;
      this.camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 5000);
    } else {
      this.camera = new THREE.PerspectiveCamera(50, this.width / this.height, 1, 5000);
    }
    this.contolled = !!controlConfig;
    if (this.contolled) {
      this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.controls.minDistance = controlSettings.minDistance;
      this.controls.maxDistance = controlSettings.maxDistance;
      this.controls.zoomSpeed = controlSettings.zoomSpeed;
      this.controls.noZoom = controlSettings.noZoom;
    }
    if (sceneSettings.cameraPosition) {
      this.camera.position.copy(sceneSettings.cameraPosition);
    }
    window.addEventListener('resize', function onWindowResize() {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      if (this.camera.type === 'OrthographicCamera') {
        var width = this.width / this.orthoZoom;
        var height = this.height / this.orthoZoom;
        this.camera.left = width / -2;
        this.camera.right = width / 2;
        this.camera.top = height / 2;
        this.camera.bottom = height / -2;
      } else {
        this.camera.aspect = this.width / this.height;
      }
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(this.width, this.height);
    }.bind(this), false);
    this.attachTo(sceneSettings.element);
  };
  Scene.prototype = {
    attachTo: function (element) {
      element.style.width = this.width + 'px';
      element.style.height = this.height + 'px';
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(this.width, this.height);
      element.appendChild(this.renderer.domElement);
    },
    add: function (mesh) {
      this.container.add(mesh);
    },
    remove: function (mesh) {
      this.container.remove(mesh);
    },
    render: function () {
      if (this.contolled)
        this.controls.update();
      this.renderer.render(this.container, this.camera);
    },
    updateOrthoZoom: function () {
      if (this.orthoZoom <= 0) {
        this.orthoZoom = 0;
        return;
      }
      var width = this.width / this.orthoZoom;
      var height = this.height / this.orthoZoom;
      this.camera.left = width / -2;
      this.camera.right = width / 2;
      this.camera.top = height / 2;
      this.camera.bottom = height / -2;
      this.camera.updateProjectionMatrix();
    },
    focusOn: function (obj) {
      this.camera.lookAt(obj.position);
    }
  };
  return Scene;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define(['lib/Signal'], function (Signal) {
  /*
  	Translates mouse interactivity into 3D positions, so we can easily pick objects in the scene.
  
  	Like everything else in ThreeJS, ray casting creates a ton of new objects each time it's used. This contributes to frequent garbage collections (causing frame hitches), so if you're limited to low-end hardware like mobile, it would be better to only update it when the user clicks, instead of every frame (so no hover effects, but on mobile those don't work anyway). You'll want to create a version that handles touch anyway.
  
  	group - any Object3D (Scene, Group, Mesh, Sprite, etc) that the mouse will cast against
  	camera - the camera to cast from
   */
  var MouseCaster = function (group, camera) {
    this.down = false;
    // the object that was just clicked on
    this.pickedObject = null;
    // the object currently being "held"
    this.selectedObject = null;
    // store the results of the last cast
    this.allHits = null;
    // disable the caster easily to temporarily prevent user input
    this.active = true;
    this.shift = false;
    this.ctrl = false;
    this.wheel = 0;
    // you can track exactly where the mouse is in the 3D scene by using the z component
    this.position = new THREE.Vector3();
    this.screenPosition = new THREE.Vector2();
    this.signal = new Signal();
    this.group = group;
    // behind-the-scenes stuff you shouldn't worry about
    this._camera = camera;
    this._raycaster = new THREE.Raycaster();
    this._preventDefault = false;
    document.addEventListener('mousemove', this._onDocumentMouseMove.bind(this), false);
    document.addEventListener('mousedown', this._onDocumentMouseDown.bind(this), false);
    document.addEventListener('mouseup', this._onDocumentMouseUp.bind(this), false);
    document.addEventListener('mousewheel', this._onMouseWheel.bind(this), false);
    document.addEventListener('DOMMouseScroll', this._onMouseWheel.bind(this), false);  // firefox
  };
  // statics to describe the events we dispatch
  MouseCaster.OVER = 'over';
  MouseCaster.OUT = 'out';
  MouseCaster.DOWN = 'down';
  MouseCaster.UP = 'up';
  MouseCaster.CLICK = 'click';
  // only fires if the user clicked down and up while on the same object
  MouseCaster.WHEEL = 'wheel';
  MouseCaster.prototype = {
    update: function () {
      if (!this.active) {
        return;
      }
      this._raycaster.setFromCamera(this.screenPosition, this._camera);
      var intersects = this._raycaster.intersectObject(this.group, true);
      var hit, obj;
      if (intersects.length > 0) {
        // get the first object under the mouse
        hit = intersects[0];
        obj = hit.object.userData.structure;
        if (this.pickedObject != obj) {
          // the first object changed, meaning there's a different one, or none at all
          if (this.pickedObject) {
            // it's a new object, notify the old object is going away
            this.signal.dispatch(MouseCaster.OUT, this.pickedObject);
          }
          /*else {
          	// hit a new object when nothing was there previously
          }*/
          this.pickedObject = obj;
          this.selectedObject = null;
          // cancel click, otherwise it'll confuse the user
          this.signal.dispatch(MouseCaster.OVER, this.pickedObject);
        }
        this.position.copy(hit.point);
        this.screenPosition.z = hit.distance;
      } else {
        // there isn't anything under the mouse
        if (this.pickedObject) {
          // there was though, we just moved out
          this.signal.dispatch(MouseCaster.OUT, this.pickedObject);
        }
        this.pickedObject = null;
        this.selectedObject = null;
      }
      this.allHits = intersects;
    },
    preventDefault: function () {
      this._preventDefault = true;
    },
    _onDocumentMouseDown: function (evt) {
      evt.preventDefault();
      if (this._preventDefault) {
        this._preventDefault = false;
        return false;
      }
      if (this.pickedObject) {
        this.selectedObject = this.pickedObject;
      }
      this.shift = evt.shiftKey;
      this.ctrl = evt.ctrlKey;
      this.down = true;
      this.signal.dispatch(MouseCaster.DOWN, this.pickedObject);
    },
    _onDocumentMouseUp: function (evt) {
      evt.preventDefault();
      if (this._preventDefault) {
        this._preventDefault = false;
        return false;
      }
      this.shift = evt.shiftKey;
      this.ctrl = evt.ctrlKey;
      this.down = false;
      this.signal.dispatch(MouseCaster.UP, this.pickedObject);
      // console.log('up');
      if (this.selectedObject && this.pickedObject && this.selectedObject.uniqueID === this.pickedObject.uniqueID) {
        // console.log('click');
        this.signal.dispatch(MouseCaster.CLICK, this.pickedObject);
      }
    },
    _onDocumentMouseMove: function (evt) {
      evt.preventDefault();
      this.screenPosition.x = evt.clientX / window.innerWidth * 2 - 1;
      this.screenPosition.y = -(evt.clientY / window.innerHeight) * 2 + 1;
    },
    _onMouseWheel: function (evt) {
      if (!this.active) {
        return;
      }
      evt.preventDefault();
      evt.stopPropagation();
      var delta = 0;
      if (evt.wheelDelta !== undefined) {
        // WebKit / Opera / Explorer 9
        delta = evt.wheelDelta;
      } else if (evt.detail !== undefined) {
        // Firefox
        delta = -evt.detail;
      }
      if (delta > 0) {
        this.wheel++;
      } else {
        this.wheel--;
      }
      // console.log(this.wheel);
      this.signal.dispatch(MouseCaster.WHEEL, this.wheel);
    }
  };
  return MouseCaster;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
    @source https://github.com/qiao/PathFinding.js/
*/
define({
  /**
   * Backtrace according to the parent records and return the path.
   * (including both start and end nodes)
   * @param {Node} node End node
   * @return {Array.<Array.<number>>} the path
   */
  backtrace: function (node) {
    var path = [node];
    while (node.parent) {
      node = node.parent;
      path.push(node);
    }
    return path.reverse();
  },
  /**
   * Backtrace from start and end node, and return the path.
   * (including both start and end nodes)
   * @param {Node}
   * @param {Node}
   */
  biBacktrace: function (nodeA, nodeB) {
    var pathA = backtrace(nodeA), pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
  },
  /**
   * Compute the length of the path.
   * @param {Array.<Array.<number>>} path The path
   * @return {number} The length of the path
   */
  pathLength: function (path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i < path.length; ++i) {
      a = path[i - 1];
      b = path[i];
      dx = a[0] - b[0];
      dy = a[1] - b[1];
      sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
  },
  /**
   * Given the start and end coordinates, return all the coordinates lying
   * on the line formed by these coordinates, based on Bresenham's algorithm.
   * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification
   * @param {number} x0 Start x coordinate
   * @param {number} y0 Start y coordinate
   * @param {number} x1 End x coordinate
   * @param {number} y1 End y coordinate
   * @return {Array.<Array.<number>>} The coordinates on the line
   */
  interpolate: function (x0, y0, x1, y1) {
    var abs = Math.abs, line = [], sx, sy, dx, dy, err, e2;
    dx = abs(x1 - x0);
    dy = abs(y1 - y0);
    sx = x0 < x1 ? 1 : -1;
    sy = y0 < y1 ? 1 : -1;
    err = dx - dy;
    while (true) {
      line.push([
        x0,
        y0
      ]);
      if (x0 === x1 && y0 === y1) {
        break;
      }
      e2 = 2 * err;
      if (e2 > -dy) {
        err = err - dy;
        x0 = x0 + sx;
      }
      if (e2 < dx) {
        err = err + dx;
        y0 = y0 + sy;
      }
    }
    return line;
  },
  /**
   * Given a compressed path, return a new path that has all the segments
   * in it interpolated.
   * @param {Array.<Array.<number>>} path The path
   * @return {Array.<Array.<number>>} expanded path
   */
  expandPath: function (path) {
    var expanded = [], len = path.length, coord0, coord1, interpolated, interpolatedLen, i, j;
    if (len < 2) {
      return expanded;
    }
    for (i = 0; i < len - 1; ++i) {
      coord0 = path[i];
      coord1 = path[i + 1];
      interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
      interpolatedLen = interpolated.length;
      for (j = 0; j < interpolatedLen - 1; ++j) {
        expanded.push(interpolated[j]);
      }
    }
    expanded.push(path[len - 1]);
    return expanded;
  },
  /**
   * Smoothen the give path.
   * The original path will not be modified; a new path will be returned.
   * @param {PF.Grid} grid
   * @param {Array.<Array.<number>>} path The path
   */
  smoothenPath: function (grid, path) {
    var len = path.length, x0 = path[0][0],
      // path start x
      y0 = path[0][1],
      // path start y
      x1 = path[len - 1][0],
      // path end x
      y1 = path[len - 1][1],
      // path end y
      sx, sy,
      // current start coordinate
      ex, ey,
      // current end coordinate
      newPath, i, j, coord, line, testCoord, blocked;
    sx = x0;
    sy = y0;
    newPath = [[
        sx,
        sy
      ]];
    for (i = 2; i < len; ++i) {
      coord = path[i];
      ex = coord[0];
      ey = coord[1];
      line = interpolate(sx, sy, ex, ey);
      blocked = false;
      for (j = 1; j < line.length; ++j) {
        testCoord = line[j];
        if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
          blocked = true;
          break;
        }
      }
      if (blocked) {
        lastValidCoord = path[i - 1];
        newPath.push(lastValidCoord);
        sx = lastValidCoord[0];
        sy = lastValidCoord[1];
      }
    }
    newPath.push([
      x1,
      y1
    ]);
    return newPath;
  },
  /**
   * Compress a path, remove redundant nodes without altering the shape
   * The original path is not modified
   * @param {Array.<Array.<number>>} path The path
   * @return {Array.<Array.<number>>} The compressed path
   */
  compressPath: function (path) {
    // nothing to compress
    if (path.length < 3) {
      return path;
    }
    var compressed = [], sx = path[0][0],
      // start x
      sy = path[0][1],
      // start y
      px = path[1][0],
      // second point x
      py = path[1][1],
      // second point y
      dx = px - sx,
      // direction between the two points
      dy = py - sy,
      // direction between the two points
      lx, ly, ldx, ldy, sq, i;
    // normalize the direction
    sq = Math.sqrt(dx * dx + dy * dy);
    dx /= sq;
    dy /= sq;
    // start the new path
    compressed.push([
      sx,
      sy
    ]);
    for (i = 2; i < path.length; i++) {
      // store the last point
      lx = px;
      ly = py;
      // store the last direction
      ldx = dx;
      ldy = dy;
      // next point
      px = path[i][0];
      py = path[i][1];
      // next direction
      dx = px - lx;
      dy = py - ly;
      // normalize
      sq = Math.sqrt(dx * dx + dy * dy);
      dx /= sq;
      dy /= sq;
      // if the direction has changed, store the point
      if (dx !== ldx || dy !== ldy) {
        compressed.push([
          lx,
          ly
        ]);
      }
    }
    // store the last point
    compressed.push([
      px,
      py
    ]);
    return compressed;
  }
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define(function () {
  var SignalBinding = function (signal, listener, isOnce, listenerContext, priority) {
    /**
    * @property _listener - Handler function bound to the signal.
    * @private
    */
    this._listener = listener;
    /**
    * @property {boolean} isOnce - If binding should be executed just once.
    * @private
    */
    this.isOnce = isOnce;
    /**
    * @property {object|undefined|null} context - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
    */
    this.context = listenerContext;
    /**
    * @property {Signal} signal - Reference to Signal object that listener is currently bound to.
    * @private
    */
    this.signal = signal;
    /**
    * @property {number} _priority - Listener priority.
    * @private
    */
    this._priority = priority || 0;
  };
  SignalBinding.prototype = {
    /**
    * If binding is active and should be executed.
    * @property {boolean} active
    * @default
    */
    active: true,
    /**
    * Default parameters passed to listener during `Signal.dispatch` and `SignalBinding.execute` (curried parameters).
    * @property {array|null} params
    * @default
    */
    params: null,
    /**
    * Call listener passing arbitrary parameters.
    * If binding was added using `Signal.addOnce()` it will be automatically removed from signal dispatch queue, this method is used internally for the signal dispatch.
    * @method SignalBinding#execute
    * @param {array} [paramsArr] - Array of parameters that should be passed to the listener.
    * @return {any} Value returned by the listener.
    */
    execute: function (paramsArr) {
      var handlerReturn, params;
      if (this.active && !!this._listener) {
        params = this.params ? this.params.concat(paramsArr) : paramsArr;
        handlerReturn = this._listener.apply(this.context, params);
        if (this.isOnce) {
          this.detach();
        }
      }
      return handlerReturn;
    },
    /**
    * Detach binding from signal.
    * alias to: @see mySignal.remove(myBinding.listener);
    * @method SignalBinding#detach
    * @return {function|null} Handler function bound to the signal or `null` if binding was previously detached.
    */
    detach: function () {
      return this.isBound() ? this.signal.remove(this._listener, this.context) : null;
    },
    /**
    * @method SignalBinding#isBound
    * @return {boolean} True if binding is still bound to the signal and has a listener.
    */
    isBound: function () {
      return !!this.signal && !!this._listener;
    },
    /**
    * Delete instance properties
    * @method SignalBinding#_destroy
    * @private
    */
    _destroy: function () {
      delete this.signal;
      delete this._listener;
      delete this.context;
    },
    /**
    * @method SignalBinding#toString
    * @return {string} String representation of the object.
    */
    toString: function () {
      return '[SignalBinding isOnce:' + this.isOnce + ', isBound:' + this.isBound() + ', active:' + this.active + ']';
    }
  };
  SignalBinding.prototype.constructor = SignalBinding;
  /**
  * @author       Miller Medeiros http://millermedeiros.github.com/js-signals/
  * @author       Richard Davey <rich@photonstorm.com>
  * @copyright    2014 Photon Storm Ltd.
  * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
  */
  /**
  * A Signal is used for object communication via a custom broadcaster instead of Events.
  *
  * @class Signal
  * @constructor
  */
  var Signal = function () {
    /**
    * @property {Array.<SignalBinding>} _bindings - Internal variable.
    * @private
    */
    this._bindings = [];
    /**
    * @property {any} _prevParams - Internal variable.
    * @private
    */
    this._prevParams = null;
    // enforce dispatch to aways work on same context (#47)
    var self = this;
    /**
    * @property {function} dispatch - The dispatch function is what sends the Signal out.
    */
    this.dispatch = function () {
      Signal.prototype.dispatch.apply(self, arguments);
    };
  };
  Signal.prototype = {
    /**
    * If Signal should keep record of previously dispatched parameters and
    * automatically execute listener during `add()`/`addOnce()` if Signal was
    * already dispatched before.
    * @property {boolean} memorize
    */
    memorize: false,
    /**
    * @property {boolean} _shouldPropagate
    * @private
    */
    _shouldPropagate: true,
    /**
    * If Signal is active and should broadcast events.
    * IMPORTANT: Setting this property during a dispatch will only affect the next dispatch, if you want to stop the propagation of a signal use `halt()` instead.
    * @property {boolean} active
    * @default
    */
    active: true,
    /**
    * @method Signal#validateListener
    * @param {function} listener - Signal handler function.
    * @param {string} fnName - Function name.
    * @private
    */
    validateListener: function (listener, fnName) {
      if (typeof listener !== 'function') {
        throw new Error('Signal: listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName));
      }
    },
    /**
    * @method Signal#_registerListener
    * @private
    * @param {function} listener - Signal handler function.
    * @param {boolean} isOnce - Should the listener only be called once?
    * @param {object} [listenerContext] - The context under which the listener is invoked.
    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added. (default = 0).
    * @return {SignalBinding} An Object representing the binding between the Signal and listener.
    */
    _registerListener: function (listener, isOnce, listenerContext, priority) {
      var prevIndex = this._indexOfListener(listener, listenerContext);
      var binding;
      if (prevIndex !== -1) {
        binding = this._bindings[prevIndex];
        if (binding.isOnce !== isOnce) {
          throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.');
        }
      } else {
        binding = new SignalBinding(this, listener, isOnce, listenerContext, priority);
        this._addBinding(binding);
      }
      if (this.memorize && this._prevParams) {
        binding.execute(this._prevParams);
      }
      return binding;
    },
    /**
    * @method Signal#_addBinding
    * @private
    * @param {SignalBinding} binding - An Object representing the binding between the Signal and listener.
    */
    _addBinding: function (binding) {
      //  Simplified insertion sort
      var n = this._bindings.length;
      do {
        n--;
      } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority);
      this._bindings.splice(n + 1, 0, binding);
    },
    /**
    * @method Signal#_indexOfListener
    * @private
    * @param {function} listener - Signal handler function.
    * @return {number} The index of the listener within the private bindings array.
    */
    _indexOfListener: function (listener, context) {
      var n = this._bindings.length;
      var cur;
      while (n--) {
        cur = this._bindings[n];
        if (cur._listener === listener && cur.context === context) {
          return n;
        }
      }
      return -1;
    },
    /**
    * Check if listener was attached to Signal.
    *
    * @method Signal#has
    * @param {function} listener - Signal handler function.
    * @param {object} [context] - Context on which listener will be executed (object that should represent the `this` variable inside listener function).
    * @return {boolean} If Signal has the specified listener.
    */
    has: function (listener, context) {
      return this._indexOfListener(listener, context) !== -1;
    },
    /**
    * Add a listener to the signal.
    *
    * @method Signal#add
    * @param {function} listener - The function to call when this Signal is dispatched.
    * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).
    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)
    * @return {SignalBinding} An Object representing the binding between the Signal and listener.
    */
    add: function (listener, listenerContext, priority) {
      this.validateListener(listener, 'add');
      return this._registerListener(listener, false, listenerContext, priority);
    },
    /**
    * Add listener to the signal that should be removed after first execution (will be executed only once).
    *
    * @method Signal#addOnce
    * @param {function} listener - The function to call when this Signal is dispatched.
    * @param {object} [listenerContext] - The context under which the listener will be executed (i.e. the object that should represent the `this` variable).
    * @param {number} [priority] - The priority level of the event listener. Listeners with higher priority will be executed before listeners with lower priority. Listeners with same priority level will be executed at the same order as they were added (default = 0)
    * @return {SignalBinding} An Object representing the binding between the Signal and listener.
    */
    addOnce: function (listener, listenerContext, priority) {
      this.validateListener(listener, 'addOnce');
      return this._registerListener(listener, true, listenerContext, priority);
    },
    /**
    * Remove a single listener from the dispatch queue.
    *
    * @method Signal#remove
    * @param {function} listener - Handler function that should be removed.
    * @param {object} [context] - Execution context (since you can add the same handler multiple times if executing in a different context).
    * @return {function} Listener handler function.
    */
    remove: function (listener, context) {
      this.validateListener(listener, 'remove');
      var i = this._indexOfListener(listener, context);
      if (i !== -1) {
        this._bindings[i]._destroy();
        //no reason to a SignalBinding exist if it isn't attached to a signal
        this._bindings.splice(i, 1);
      }
      return listener;
    },
    /**
    * Remove all listeners from the Signal.
    *
    * @method Signal#removeAll
    * @param {object} [context=null] - If specified only listeners for the given context will be removed.
    */
    removeAll: function (context) {
      if (typeof context === 'undefined') {
        context = null;
      }
      var n = this._bindings.length;
      while (n--) {
        if (context) {
          if (this._bindings[n].context === context) {
            this._bindings[n]._destroy();
            this._bindings.splice(n, 1);
          }
        } else {
          this._bindings[n]._destroy();
        }
      }
      if (!context) {
        this._bindings.length = 0;
      }
    },
    /**
    * Gets the total number of listeneres attached to ths Signal.
    *
    * @method Signal#getNumListeners
    * @return {number} Number of listeners attached to the Signal.
    */
    getNumListeners: function () {
      return this._bindings.length;
    },
    /**
    * Stop propagation of the event, blocking the dispatch to next listeners on the queue.
    * IMPORTANT: should be called only during signal dispatch, calling it before/after dispatch won't affect signal broadcast.
    * @see Signal.prototype.disable
    *
    * @method Signal#halt
    */
    halt: function () {
      this._shouldPropagate = false;
    },
    /**
    * Dispatch/Broadcast Signal to all listeners added to the queue.
    *
    * @method Signal#dispatch
    * @param {any} [params] - Parameters that should be passed to each handler.
    */
    dispatch: function () {
      if (!this.active) {
        return;
      }
      var paramsArr = Array.prototype.slice.call(arguments);
      var n = this._bindings.length;
      var bindings;
      if (this.memorize) {
        this._prevParams = paramsArr;
      }
      if (!n) {
        //  Should come after memorize
        return;
      }
      bindings = this._bindings.slice();
      //clone array in case add/remove items during dispatch
      this._shouldPropagate = true;
      //in case `halt` was called before dispatch or during the previous dispatch.
      //execute all callbacks until end of the list or until a callback returns `false` or stops propagation
      //reverse loop since listeners with higher priority will be added at the end of the list
      do {
        n--;
      } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false);
    },
    /**
    * Forget memorized arguments.
    * @see Signal.memorize
    *
    * @method Signal#forget
    */
    forget: function () {
      this._prevParams = null;
    },
    /**
    * Remove all bindings from signal and destroy any reference to external objects (destroy Signal object).
    * IMPORTANT: calling any method on the signal instance after calling dispose will throw errors.
    *
    * @method Signal#dispose
    */
    dispose: function () {
      this.removeAll();
      delete this._bindings;
      delete this._prevParams;
    },
    /**
    *
    * @method Signal#toString
    * @return {string} String representation of the object.
    */
    toString: function () {
      return '[Signal active:' + this.active + ' numListeners:' + this.getNumListeners() + ']';
    }
  };
  Signal.prototype.constructor = Signal;
  return Signal;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define(function () {
  var LinkedListNode = function () {
    this.obj = null;
    this.next = null;
    this.prev = null;
    this.free = true;
  };
  /*
  	A high-speed doubly-linked list of objects. Note that for speed reasons (using a dictionary lookup of
  	cached nodes) there can only be a single instance of an object in the list at the same time. Adding the same
  	object a second time will result in a silent return from the add method.
  
  	In order to keep a track of node links, an object must be able to identify itself with a uniqueID function.
  
  	To add an item use:
  	<pre><code>
  	  list.add(newItem);
  	</code></pre>
  	<p>
  	You can iterate using the first and next members, such as:
  	<pre><code>
  	  var node = list.first;
  	  while (node)
  	  {
  	      node.object().DOSOMETHING();
  	      node = node.next();
  	  }
  	</code></pre>
   */
  var LinkedList = function () {
    this.first = null;
    this.last = null;
    this.length = 0;
    this.objToNodeMap = {};
    // a quick lookup list to map linked list nodes to objects
    this.uniqueID = Date.now() + '' + Math.floor(Math.random() * 1000);
    this.sortArray = [];
    /*
    Get the LinkedListNode for this object.
    @param obj The object to get the node for
    */
    this.getNode = function (obj) {
      // objects added to a list must implement a uniqueID which returns a unique object identifier string
      return this.objToNodeMap[obj.uniqueID];
    };
    /*
    Adds a new node to the list -- typically only used internally unless you're doing something funky
    Use add() to add an object to the list, not this.
    */
    this.addNode = function (obj) {
      var node = new LinkedListNode();
      if (!obj.uniqueID) {
        try {
          obj.uniqueID = LinkedList.generateID();
          console.log('New ID: ' + obj.uniqueID);
        } catch (err) {
          console.error('[LinkedList.addNode] obj passed is immutable: cannot attach necessary identifier');
          return null;
        }
      }
      node.obj = obj;
      node.free = false;
      this.objToNodeMap[obj.uniqueID] = node;
      return node;
    };
    this.swapObjects = function (node, newObj) {
      this.objToNodeMap[node.obj.uniqueID] = null;
      this.objToNodeMap[newObj.uniqueID] = node;
      node.obj = newObj;
    };
    /*
    Add an item to the list
    @param obj The object to add
    */
    this.add = function (obj) {
      var node = this.objToNodeMap[obj.uniqueID];
      if (!node) {
        node = this.addNode(obj);
      } else {
        if (node.free === false)
          return;
        // reusing a node, so we clean it up
        // this caching of node/object pairs is the reason an object can only exist
        // once in a list -- which also makes things faster (not always creating new node
        // object every time objects are moving on and off the list
        node.obj = obj;
        node.free = false;
        node.next = null;
        node.prev = null;
      }
      // append this obj to the end of the list
      if (!this.first) {
        // is this the first?
        this.first = node;
        this.last = node;
        node.next = null;
        // clear just in case
        node.prev = null;
      } else {
        if (!this.last) {
          throw new Error('[LinkedList.add] No last in the list -- that shouldn\'t happen here');
        }
        // add this entry to the end of the list
        this.last.next = node;
        // current end of list points to the new end
        node.prev = this.last;
        this.last = node;
        // new object to add becomes last in the list
        node.next = null;  // just in case this was previously set
      }
      this.length++;
      if (this.showDebug)
        this.dump('after add');
    };
    this.has = function (obj) {
      return !!this.objToNodeMap[obj.uniqueID];
    };
    /*
    Moves this item upwards in the list
    @param obj
    */
    this.moveUp = function (obj) {
      this.dump('before move up');
      var c = this.getNode(obj);
      if (!c)
        throw 'Oops, trying to move an object that isn\'t in the list';
      if (!c.prev)
        return;
      // already first, ignore
      // This operation makes C swap places with B:
      // A <-> B <-> C <-> D
      // A <-> C <-> B <-> D
      var b = c.prev;
      var a = b.prev;
      // fix last
      if (c == this.last)
        this.last = b;
      var oldCNext = c.next;
      if (a)
        a.next = c;
      c.next = b;
      c.prev = b.prev;
      b.next = oldCNext;
      b.prev = c;
      // check to see if we are now first
      if (this.first == b)
        this.first = c;
    };
    /*
    Moves this item downwards in the list
    @param obj
    */
    this.moveDown = function (obj) {
      var b = this.getNode(obj);
      if (!b)
        throw 'Oops, trying to move an object that isn\'t in the list';
      if (!b.next)
        return;
      // already last, ignore
      // This operation makes B swap places with C:
      // A <-> B <-> C <-> D
      // A <-> C <-> B <-> D
      var c = b.next;
      this.moveUp(c.obj);
      // check to see if we are now last
      if (this.last == c)
        this.last = b;
    };
    /*
    Take everything off the list and put it in an array, sort it, then put it back.
    */
    this.sort = function (compare) {
      var sortArray = this.sortArray;
      var i, l, node = this.first;
      sortArray.length = 0;
      while (node) {
        sortArray.push(node.obj);
        node = node.next;
      }
      this.clear();
      sortArray.sort(compare);
      // console.log(sortArray);
      l = sortArray.length;
      for (i = 0; i < l; i++) {
        this.add(sortArray[i]);
      }
    };
    /*
    Removes an item from the list
    @param obj The object to remove
    @returns boolean true if the item was removed, false if the item was not on the list
    */
    this.remove = function (obj) {
      var node = this.getNode(obj);
      if (!node || node.free) {
        return false;  // ignore this error (trying to remove something not there)
      }
      // pull this object out and tie up the ends
      if (node.prev)
        node.prev.next = node.next;
      if (node.next)
        node.next.prev = node.prev;
      // fix first and last
      if (!node.prev)
        // if this was first on the list
        this.first = node.next;
      // make the next on the list first (can be null)
      if (!node.next)
        // if this was the last
        this.last = node.prev;
      // then this node's previous becomes last
      node.free = true;
      node.prev = null;
      node.next = null;
      this.length--;
      return true;
    };
    // remove the head and return it's object
    this.shift = function () {
      var node = this.first;
      if (this.length === 0)
        return null;
      // if (node == null || node.free == true) return null;
      // pull this object out and tie up the ends
      if (node.prev) {
        node.prev.next = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      }
      // make the next on the list first (can be null)
      this.first = node.next;
      if (!node.next)
        this.last = null;
      // make sure we clear this
      node.free = true;
      node.prev = null;
      node.next = null;
      this.length--;
      return node.obj;
    };
    // remove the tail and return it's object
    this.pop = function () {
      var node = this.last;
      if (this.length === 0)
        return null;
      // pull this object out and tie up the ends
      if (node.prev) {
        node.prev.next = node.next;
      }
      if (node.next) {
        node.next.prev = node.prev;
      }
      // this node's previous becomes last
      this.last = node.prev;
      if (!node.prev)
        this.first = null;
      // make sure we clear this
      node.free = true;
      node.prev = null;
      node.next = null;
      this.length--;
      return node.obj;
    };
    /**
    * Add the passed list to this list, leaving it untouched.
    */
    this.concat = function (list) {
      var node = list.first;
      while (node) {
        this.add(node.obj);
        node = node.next;
      }
    };
    /**
    * Clears the list out
    */
    this.clear = function () {
      var next = this.first;
      while (next) {
        next.free = true;
        next = next.next;
      }
      this.first = null;
      this.length = 0;
    };
    this.dispose = function () {
      var next = this.first;
      while (next) {
        next.obj = null;
        next = next.next;
      }
      this.first = null;
      this.objToNodeMap = null;
    };
    /*
    Outputs the contents of the current list for debugging.
    */
    this.dump = function (msg) {
      console.log('====================' + msg + '=====================');
      var a = this.first;
      while (a) {
        console.log('{' + a.obj.toString() + '} previous=' + (a.prev ? a.prev.obj : 'NULL'));
        a = a.next();
      }
      console.log('===================================');
      console.log('Last: {' + (this.last ? this.last.obj : 'NULL') + '} ' + 'First: {' + (this.first ? this.first.obj : 'NULL') + '}');
    };
  };
  // static function for utility
  LinkedList.generateID = function () {
    return Math.random().toString(36).slice(2) + Date.now();
  };
  return LinkedList;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	2D square graph. Handles grid cell management (placement math for eg pathfinding, range-finding, etc), exposes generalized interface.
 */
define([
  'graphs/Square',
  'utils/Tools'
], function (Square, Tools) {
  var SquareGrid = function (config) {
    var x, z, c;
    if (!config)
      config = {};
    var gridSettings = {
      width: 5,
      height: 5,
      type: Square.FLAT,
      cellSize: 10,
      cellScale: 0.95,
      extrudeSettings: {
        amount: 1,
        bevelEnabled: true,
        bevelSegments: 1,
        steps: 1,
        bevelSize: 0.5,
        bevelThickness: 0.5
      }
    };
    Tools.merge(true, gridSettings, config);
    this.width = gridSettings.width;
    this.height = gridSettings.height;
    this.cellSize = gridSettings.cellSize;
    this.cellScale = gridSettings.cellScale;
    this.type = gridSettings.type || Square.FLAT;
    this.rotationIncrement = Square.POINTY;
    // holds the grid position of each cell, to which our meshes are attached to in the Board entity
    this.cells = {};
    this.numCells = 0;
    // holds the mesh data that is displayed
    this.meshes = null;
    this.boxShape = null;
    this.boxGeo = null;
    this.boxMat = gridSettings.material;
    this.hashDelimeter = '.';
    // the grid holds its own Group to manipulate and make it easy to add/remove from the scene
    this.group = new THREE.Group();
    // construct a box-shaped grid, centered
    var halfW = this.width / 2;
    var halfH = this.height / 2;
    for (x = -halfW; x < halfW; x++) {
      for (z = -halfH; z < halfH; z++) {
        c = new THREE.Vector3(x, 0, z + 1);
        c.w = null;
        // for storing which box is representing this cell
        this.cells[this.boxToHash(c)] = c;
        this.numCells++;
      }
    }
    var i, box, cell;
    this.boxShape = new THREE.Shape();
    this.boxShape.moveTo(0, 0);
    this.boxShape.lineTo(0, this.cellSize);
    this.boxShape.lineTo(this.cellSize, this.cellSize);
    this.boxShape.lineTo(this.cellSize, 0);
    this.boxShape.lineTo(0, 0);
    // this.boxGeo = new THREE.ShapeGeometry(this.boxShape);
    this.boxGeo = new THREE.ExtrudeGeometry(this.boxShape, gridSettings.extrudeSettings);
    // create Square instances and place them on the grid, and add them to the group for easy management
    this.meshes = [];
    for (i in this.cells) {
      box = new Square(this.cellSize, this.cellScale, this.boxGeo, this.boxMat);
      cell = this.cells[i];
      cell.w = box;
      box.depth = gridSettings.extrudeSettings.amount;
      box.placeAt(cell);
      this.meshes.push(box);
      this.group.add(box.mesh);
    }
    // rotate the group depending on the shape the grid is in
    this.group.rotation.y = this.type;
    // pre-computed permutations
    this._directions = [
      new THREE.Vector3(+1, 0, 0),
      new THREE.Vector3(0, 0, -1),
      new THREE.Vector3(-1, 0, 0),
      new THREE.Vector3(0, 0, +1)
    ];
    this._diagonals = [
      new THREE.Vector3(-1, 0, -1),
      new THREE.Vector3(-1, 0, +1),
      new THREE.Vector3(+1, 0, +1),
      new THREE.Vector3(+1, 0, -1)
    ];
    // cached objects
    this._list = [];
    this._vec3 = new THREE.Vector3();
  };
  SquareGrid.prototype = {
    /*
    High-level functions that the Board interfaces with (all grids implement).
    */
    // grid cell (Hex in this case) to position in pixels/world
    cellToPixel: function (c, pos) {
      pos.x = c.position.x + this.cellSize / 2;
      pos.y = c.depth + c.depth / 2;
      pos.z = c.position.z - this.cellSize / 2;
    },
    // always returns an array
    getNeighbors: function (box, diagonal, filter) {
      var i, c, l = this._directions.length;
      this._list.length = 0;
      for (i = 0; i < l; i++) {
        this._vec3.copy(box.gridPos);
        this._vec3.add(this._directions[i]);
        c = this.cells[this.boxToHash(this._vec3)];
        if (!c || filter && filter(c.w)) {
          continue;
        }
        this._list.push(c.w);
      }
      if (diagonal) {
        for (i = 0; i < l; i++) {
          this._vec3.copy(box.gridPos);
          this._vec3.add(this._diagonals[i]);
          c = this.cells[this.boxToHash(this._vec3)];
          if (!c || filter && filter(c.w)) {
            continue;
          }
          this._list.push(c.w);
        }
      }
      return this._list;
    },
    distance: function (cellA, cellB) {
      var a = cellA.gridPos;
      var b = cellB.gridPos;
      // console.log('distance: '+(Math.abs(a.x - b.x) + Math.abs(a.z - b.z)));
      return Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
    },
    clearPath: function () {
      var i, c;
      for (i in this.cells) {
        c = this.cells[i].w;
        c.calcCost = 0;
        c.priority = 0;
        c.parent = null;
        c.visited = false;
      }
    },
    traverse: function (cb) {
      var i;
      for (i in this.cells) {
        cb(this.cells[i].w);
      }
    },
    getRandomCell: function () {
      var c, i = 0, x = Tools.randomInt(0, this.numCells);
      for (c in this.cells) {
        if (i === x) {
          return this.cells[c].w;
        }
        i++;
      }
      return this.cells[c].w;
    },
    /*
    Square-specific conversion math.
    */
    boxToHash: function (box) {
      return box.x + this.hashDelimeter + box.z;
    }
  };
  return SquareGrid;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	Grid cell that constructs its geometry for rendering and holds gameplay properties.
 */
define(['utils/Tools'], function (Tools) {
  var Square = function (size, scale, geometry, material) {
    this.type = Square.FLAT;
    this.material = material;
    this.geo = geometry;
    this.size = size;
    this.depth = size;
    this.uniqueID = Tools.generateID();
    this.objectType = 'cell';
    // Board.Cell
    this.gridPos = null;
    // reference to cell object (a Vec3) in grid that this view represents
    this.entity = null;
    // reference to cell object in grid that this view represents
    this.width = size;
    this.height = size;
    // horizontal
    this.selected = false;
    this.highlight = '0x222266';
    this.walkable = true;
    // path option
    // used by pathfinder, overwritten at runtime, don't touch
    this.calcCost = 0;
    this.priority = 0;
    this.visited = false;
    this.parent = null;
    var color = Tools.randomizeRGB('30, 30, 30', 10);
    if (!this.material) {
      this.material = new THREE.MeshPhongMaterial({
        color: color,
        ambient: color
      });
    }
    this.mesh = new THREE.Mesh(geometry, this.material);
    /*this.mesh = new THREE.Line(this.shape.createPointsGeometry(), new THREE.LineBasicMaterial({
    		color: this.color,
    		linewidth: 3 // this doesn't work on windows because ANGLE doesn't implement it (the WebGL driver)
    	}));*/
    this.mesh.userData.structure = this;
    // create references so we can control orientation through this (Square), instead of drilling down
    this.position = this.mesh.position;
    this.rotation = this.mesh.rotation;
    // rotate it to face "up" (Y+)
    this.rotation.x = -90 * 0.0174532925;
    this.mesh.scale.set(scale, scale, scale);
    this._emissive = this.material.emissive.getHex();
  };
  Square.FLAT = 0;
  Square.POINTY = 45 * 0.0174532925;
  Square.prototype = {
    select: function () {
      this.material.emissive.setHex(this.highlight);
      this.selected = true;
    },
    deselect: function () {
      this.material.emissive.setHex(this._emissive);
      this.selected = false;
    },
    placeAt: function (cell) {
      this.position.x = cell.x * this.size;
      this.position.y = 0;
      this.position.z = cell.z * this.size;
      this.gridPos = cell;
    }
  };
  return Square;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	Graph of hexagons. Handles grid cell management (placement math for eg pathfinding, range, etc) and grid conversion math.
	[Cube coordinate system](http://www.redblobgames.com/grids/hexagons/).
	@author Corey Birnbaum https://github.com/vonWolfehaus/
 */
define([
  'utils/Loader',
  'graphs/Hex',
  'utils/Tools'
], function (Loader, Hex, Tools) {
  var HexGrid = function (config) {
    if (!config)
      config = {};
    var gridSettings = {
      rings: 5,
      // creates a hexagon-shaped grid of this size
      url: null,
      // loads in map JSON data for arbitrary/sparse maps created with the editor
      // depthStep: 2,
      cellSize: 10,
      cellDepth: 1,
      cellScale: 0.95,
      extrudeSettings: {
        amount: 1,
        // this gets overwritten, use cellDepth instead
        bevelEnabled: true,
        bevelSegments: 1,
        steps: 1,
        bevelSize: 0.5,
        bevelThickness: 0.5
      }
    };
    Tools.merge(true, gridSettings, config);
    // number of cells (in radius); only used if the map is generated
    this.size = gridSettings.rings;
    this.cellSize = gridSettings.cellSize;
    this.cellScale = gridSettings.cellScale;
    this.extrudeSettings = gridSettings.extrudeSettings;
    this.extrudeSettings.amount = gridSettings.cellDepth;
    this.rotationIncrement = 30 * Tools.DEG_TO_RAD;
    // holds the grid position of each cell in cube coordinates, to which our meshes are attached to in the Board entity
    this.cells = {};
    // it's a hash so we can have sparse maps
    this.numCells = 0;
    // holds the Hex instances data that is displayed; still working on a decent naming convention, sorry
    this.meshes = [];
    this.hexShape = null;
    this.hexWidth = 0;
    this.hexHeight = 0;
    this.hashDelimeter = '.';
    // the grid holds its own Object3D to manipulate and make it easy to add/remove from the scene
    this.group = new THREE.Object3D();
    // create base shape used for building geometry
    var i, verts = [];
    // create the skeleton of the hex
    for (i = 0; i < 6; i++) {
      verts.push(this.createVert(i, Hex.FLAT));
    }
    // copy the verts into a shape for the geometry to use
    this.hexShape = new THREE.Shape();
    this.hexShape.moveTo(verts[0].x, verts[0].y);
    for (i = 1; i < 6; i++) {
      this.hexShape.lineTo(verts[i].x, verts[i].y);
    }
    this.hexShape.lineTo(verts[0].x, verts[0].y);
    // pre-computed permutations
    this._directions = [
      new THREE.Vector3(+1, -1, 0),
      new THREE.Vector3(+1, 0, -1),
      new THREE.Vector3(0, +1, -1),
      new THREE.Vector3(-1, +1, 0),
      new THREE.Vector3(-1, 0, +1),
      new THREE.Vector3(0, -1, +1)
    ];
    this._diagonals = [
      new THREE.Vector3(+2, -1, -1),
      new THREE.Vector3(+1, +1, -2),
      new THREE.Vector3(-1, +2, -1),
      new THREE.Vector3(-2, +1, +1),
      new THREE.Vector3(-1, -1, +2),
      new THREE.Vector3(+1, -2, +1)
    ];
    // cached objects
    this._list = [];
    this._vec3 = new THREE.Vector3();
    this._conversionVec = new THREE.Vector3();
    this._geoCache = [];
    this._matCache = [];
    // build the grid depending on what was passed in
    if (gridSettings.url) {
      Tools.getJSON(gridSettings.url, this.onLoad, this);
    } else {
      this.generate();
    }
    var c = this.getRandomCell();
    this.hexWidth = c.width;
    this.hexHeight = c.height;
  };
  HexGrid.SQRT3 = Math.sqrt(3);
  // used often in conversions
  HexGrid.prototype = {
    /*
    ________________________________________________________________________
    High-level functions that the Board interfaces with (all grids implement)
    */
    // grid cell (Hex in this case) to position in pixels/world
    cellToPixel: function (c, pos) {
      var p = this.hexToPixel(c.gridPos);
      pos.x = p.x;
      pos.y = c.depth;
      pos.z = -p.y;
    },
    // "flat" version only; if you want a pointy version, rotate the camera by 30 degrees
    pixelToCell: function (pos) {
      var q = pos.x * (2 / 3 / this.cellSize);
      var r = (-pos.x / 3 + HexGrid.SQRT3 / 3 * pos.y) / this.cellSize;
      this._vec3.set(q, r, 0);
      return this.hexRound(this._vec3);
    },
    // always returns an array
    getNeighbors: function (hex, diagonal, filter) {
      var i, c, l = this._directions.length;
      this._list.length = 0;
      for (i = 0; i < l; i++) {
        this._vec3.copy(hex.gridPos);
        this._vec3.add(this._directions[i]);
        c = this.cells[this.cubeToHash(this._vec3)];
        if (!c || filter && !filter(hex, c.w)) {
          continue;
        }
        this._list.push(c.w);
      }
      if (diagonal) {
        for (i = 0; i < l; i++) {
          this._vec3.copy(hex.gridPos);
          this._vec3.add(this._diagonals[i]);
          c = this.cells[this.cubeToHash(this._vec3)];
          if (!c || filter && !filter(hex, c.w)) {
            continue;
          }
          this._list.push(c.w);
        }
      }
      return this._list;
    },
    distance: function (cellA, cellB) {
      var d = this.cubeDistance(cellA.gridPos, cellB.gridPos);
      d += cellB.depth - cellA.depth;
      return d;
    },
    clearPath: function () {
      var i, c;
      for (i in this.cells) {
        c = this.cells[i].w;
        c.calcCost = 0;
        c.priority = 0;
        c.parent = null;
        c.visited = false;
      }
    },
    traverse: function (cb) {
      var i;
      for (i in this.cells) {
        cb(this.cells[i].w);
      }
    },
    getRandomCell: function () {
      var c, i = 0, x = Tools.randomInt(0, this.numCells);
      for (c in this.cells) {
        if (i === x) {
          return this.cells[c].w;
        }
        i++;
      }
      return this.cells[c].w;
    },
    // handy for selection hinting
    generateCellView: function (height, material) {
      height = Math.abs(height) || this.extrudeSettings.amount;
      this.extrudeSettings.amount = height;
      var geo = this._geoCache[height];
      if (!geo) {
        geo = new THREE.ExtrudeGeometry(this.hexShape, this.extrudeSettings);
        this._geoCache[height] = geo;
      }
      var hex = new Hex(this.cellSize, this.cellScale, geo, material);
      hex.depth = height;
      return hex;
    },
    // make a new cell for the hex
    add: function (gridPos, hex) {
      var c = new THREE.Vector3();
      c.copy(gridPos);
      if (!hex) {
        hex = this.generateCellView();
      }
      c.w = hex;
      hex.placeAt(c);
      this.cells[this.cubeToHash(c)] = c;
      this.meshes.push(hex);
      this.group.add(hex.mesh);
      this.numCells++;
    },
    remove: function (hex) {
      delete this.cells[this.cubeToHash(hex.gridPos)];
      hex.gridPos.w = null;
      var i = this.meshes.indexOf(hex);
      if (i !== -1) {
        this.meshes.splice(i, 1);
      }
      this.group.remove(hex.mesh);
      this.numCells--;
      hex.dispose();
    },
    dispose: function () {
    },
    /*
    ________________________________________________________________________
    Hexagon-specific conversion math
    */
    cubeToHash: function (cube) {
      return cube.x + this.hashDelimeter + cube.y + this.hashDelimeter + cube.z;
    },
    /*pixelToAxial: function(x, y) {
    		var q = (x * (HexGrid.SQRT3 / 3) - (y / 3)) / this.cellSize;
    		var r = y * (2 / 3) / this.cellSize;
    		// var axial = this.hexRound(this._conversionVec.set(q, r, 0));
    		var axial = this.hexRound({x: q, y: r});
    		return this.hexToCube(axial);
    	},*/
    hexToCube: function (h) {
      return {
        x: h.x,
        y: h.y,
        z: -h.x - h.y
      };  // return this._conversionVec.set(h.x, h.y, -h.x - h.y);
    },
    cubeToHex: function (h) {
      return h;  // {x: h.x, y: h.y};
    },
    hexToPixel: function (h) {
      var x, y;
      x = h.x * this.hexWidth * 0.75;
      y = (h.z - h.y) * this.hexHeight * 0.5;
      return {
        x: x,
        y: -y
      };  // return this._conversionVec.set(x, y, 0);
    },
    /*axialToPixel: function(cube) {
    		var xOffset = cube.z * (this.hexWidth / 2);
    		var xCoord = (cube.x * this.hexWidth) + xOffset;
    		var zCoord = cube.z * this.hexHeight * 0.75;
    		return {x: xCoord, y: 0, z: zCoord};
    		// return this._conversionVec.set(xCoord, 0, zCoord);
    	},*/
    hexRound: function (h) {
      return /*this.cubeToHex(*/
      this.cubeRound(this.hexToCube(h));
    },
    cubeRound: function (h) {
      var rx = Math.round(h.x);
      var ry = Math.round(h.y);
      var rz = Math.round(h.z);
      var x_diff = Math.abs(rx - h.x);
      var y_diff = Math.abs(ry - h.y);
      var z_diff = Math.abs(rz - h.z);
      if (x_diff > y_diff && x_diff > z_diff) {
        rx = -ry - rz;
      } else if (y_diff > z_diff) {
        ry = -rx - rz;
      } else {
        rz = -rx - ry;
      }
      // return {x: rx, y: ry, z: rz};
      return this._conversionVec.set(rx, ry, rz);
    },
    hexDistance: function (a, b) {
      var ac = hexToCube(a);
      var bc = hexToCube(b);
      return this.cubeDistance(ac, bc);
    },
    cubeDistance: function (a, b) {
      return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y), Math.abs(a.z - b.z));
    },
    createVert: function (i, type) {
      var angle = 2 * Math.PI / 6 * i;
      angle += type;
      // 0 if flat-topped, or 30deg if pointy
      return new THREE.Vector3(this.cellSize * Math.cos(angle), this.cellSize * Math.sin(angle), 0);
    },
    // create a flat, hexagon-shaped grid.
    generate: function () {
      var x, y, z, c, i, hex;
      c = new THREE.Vector3();
      this.meshes = [];
      for (x = -this.size; x < this.size + 1; x++) {
        for (y = -this.size; y < this.size + 1; y++) {
          z = -x - y;
          if (Math.abs(x) <= this.size && Math.abs(y) <= this.size && Math.abs(z) <= this.size) {
            c.set(x, y, z);
            this.add(c);
          }
        }
      }
    },
    /* load a grid from a parsed json object.
    xyz are hex cube coordinates
    json = {
    	cells: [
    		{x, y, z, depth, mat_cache_id, custom_data},
    		...
    	],
    	materials: [
    		{
    			cache_id: 0,
    			type: 'MeshLambertMaterial',
    			color, ambient, emissive, reflectivity, refractionRatio, wrapAround,
    			imgURL: url
    		},
    		{
    			cache_id: 1, ...
    		}
    		...
    	]
    }*/
    onLoad: function (json) {
      console.log(json);
      var i, c, v, hex, geo, mat;
      var cells = json.cells;
      this.meshes = [];
      this.group = new THREE.Object3D();
      this.cells = {};
      this.numCells = 0;
      // create Hex instances and place them on the grid, and add them to the group for easy management
      for (i = 0; i < cells.length; i++) {
        c = cells[i];
        geo = this._geoCache[c.depth];
        if (!geo) {
          this.extrudeSettings.amount = c.depth;
          geo = new THREE.ExtrudeGeometry(this.hexShape, this.extrudeSettings);
          this._geoCache[c.depth] = geo;
        }
        /*mat = this._matCache[c.matConfig.mat_cache_id];
        	if (!mat) { // MaterialLoader? we currently only support basic stuff though. maybe later
        		mat.map = Loader.loadTexture(c.matConfig.imgURL);
        		delete c.matConfig.imgURL;
        		mat = new THREE[c.matConfig.type](c.matConfig);
        		this._matCache[c.matConfig.mat_cache_id] = mat;
        	}*/
        hex = new Hex(this.cellSize, this.cellScale, geo, mat);
        hex.depth = this.extrudeSettings.amount;
        hex.userData.mapData = c.custom_data;
        this.add(c, hex);
      }
    }
  };
  return HexGrid;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	Grid cell that constructs its geometry for rendering and holds gameplay properties.
 */
define(['utils/Tools'], function (Tools) {
  var Hex = function (size, scale, geometry, material) {
    this.material = material;
    this.geo = geometry;
    this.size = size;
    this.width = this.size * 2;
    this.height = Math.sqrt(3) / 2 * this.width;
    this.depth = size;
    this.uniqueID = Tools.generateID();
    this.objectType = 'cell';
    // Board.Cell
    this.gridPos = null;
    // reference to cube coordinate (a Vec3) in grid that this view represents
    this.entity = null;
    this.userData = {};
    this.selected = false;
    this.highlight = '0x222266';
    // path options
    this.walkable = true;
    // used by pathfinder, overwritten at runtime, don't touch
    this.calcCost = 0;
    this.priority = 0;
    this.visited = false;
    this.parent = null;
    var color = Tools.randomizeRGB('30, 30, 30', 10);
    if (!this.material) {
      this.material = new THREE.MeshPhongMaterial({
        // shiny!
        color: color
      });
    }
    this.mesh = new THREE.Mesh(geometry, this.material);
    /*this.mesh = new THREE.Line(this.shape.createPointsGeometry(), new THREE.LineBasicMaterial({
    		color: this.color,
    		linewidth: 3 // this doesn't work on windows because ANGLE doesn't implement it (the WebGL->DirectX translator)
    	}));*/
    this.mesh.userData.structure = this;
    // create references so we can control orientation through this (Hex), instead of drilling down
    this.position = this.mesh.position;
    this.rotation = this.mesh.rotation;
    // rotate it to face "up" (Y+)
    this.rotation.x = -90 * Tools.DEG_TO_RAD;
    this.mesh.scale.set(scale, scale, scale);
    if (this.material.emissive) {
      this._emissive = this.material.emissive.getHex();
    } else {
      this._emissive = null;
    }
  };
  Hex.FLAT = 0;
  Hex.POINTY = 30 * Tools.DEG_TO_RAD;
  Hex.prototype = {
    select: function () {
      if (this.material.emissive) {
        this.material.emissive.setHex(this.highlight);
      }
      this.selected = true;
      return this;
    },
    deselect: function () {
      if (this._emissive !== null && this.material.emissive) {
        this.material.emissive.setHex(this._emissive);
      }
      this.selected = false;
      return this;
    },
    // Hexagon cells are in cube coordinates; this is a modified HexGrid.hexToPixel
    placeAt: function (cell) {
      this.position.x = cell.x * this.width * 0.75;
      this.position.y = 0;
      this.position.z = (cell.z - cell.y) * this.height * 0.5;
      this.gridPos = cell;
      cell.w = this;
    },
    dispose: function () {
    }
  };
  return Hex;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define([
  'utils/Tools',
  'pathing/Util',
  'lib/LinkedList'
], function (Tools, Util, LinkedList) {
  /*
  	A* path-finder based upon http://www.redblobgames.com/pathfinding/a-star/introduction.html
  	@author Corey Birnbaum https://github.com/vonWolfehaus/
   */
  function AStarFinder(finderConfig) {
    finderConfig = finderConfig || {};
    this.allowDiagonal = false;
    this.heuristicFilter = null;
    Tools.merge(this, finderConfig);
    this.list = new LinkedList();
  }
  AStarFinder.prototype = {
    /*
    Find and return the path.
    @return Array<Cell> The path, including both start and end positions. Null if it failed.
    */
    findPath: function (startNode, endNode, heuristic, grid) {
      var current, costSoFar, neighbors, neighbor, i, l;
      heuristic = heuristic || this.heuristicFilter;
      // clear old values from previous finding
      grid.clearPath();
      this.list.clear();
      // push the start current into the open list
      this.list.add(startNode);
      // while the open list is not empty
      while (this.list.length > 0) {
        // sort so lowest cost is first
        this.list.sort(this.compare);
        // pop the position of current which has the minimum `calcCost` value.
        current = this.list.shift();
        current.visited = true;
        // if reached the end position, construct the path and return it
        if (current === endNode) {
          return Util.backtrace(endNode);
        }
        // cycle through each neighbor of the current current
        neighbors = grid.getNeighbors(current, this.allowDiagonal, heuristic);
        for (i = 0, l = neighbors.length; i < l; i++) {
          neighbor = neighbors[i];
          if (!neighbor.walkable) {
            continue;
          }
          costSoFar = current.calcCost + grid.distance(current, neighbor);
          // check if the neighbor has not been inspected yet, or can be reached with smaller cost from the current current
          if (!neighbor.visited || costSoFar < neighbor.calcCost) {
            neighbor.visited = true;
            neighbor.parent = current;
            neighbor.calcCost = costSoFar;
            // priority is the most important property, since it makes the algorithm "greedy" and seek the goal.
            // otherwise it behaves like a brushfire/breadth-first.
            neighbor.priority = costSoFar + grid.distance(endNode, neighbor);
            // check neighbor if it's the end current as well--often cuts steps by a significant amount
            if (neighbor === endNode) {
              return Util.backtrace(endNode);
            }
            this.list.add(neighbor);
          }
        }  // end for each neighbor
      }
      // end while not open list empty
      // failed to find the path
      return null;
    },
    compare: function (nodeA, nodeB) {
      return nodeA.priority - nodeB.priority;
    }
  };
  return AStarFinder;
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
define({
  manager: null,
  imageLoader: null,
  crossOrigin: false,
  init: function (crossOrigin) {
    this.crossOrigin = crossOrigin || false;
    this.manager = new THREE.LoadingManager(function () {
    }, function () {
    }, function () {
      console.warn('Error loading images');
    });
    this.imageLoader = new THREE.ImageLoader(this.manager);
    this.imageLoader.crossOrigin = crossOrigin;
  },
  loadTexture: function (url, mapping, onLoad, onError) {
    var texture = new THREE.Texture(undefined, mapping);
    loader.load(url, function (image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad)
        onLoad(texture);
    }, undefined, function (event) {
      if (onError)
        onError(event);
    });
    texture.sourceFile = url;
    return texture;
  }
});}(typeof THREE !== "undefined" ? THREE : null));
(function(THREE) {
/*
	Interface to the grid. Holds data about what's occupying cells, and a general interface from entities to cells.

	@author Corey Birnbaum https://github.com/vonWolfehaus/
 */
define([
  'utils/Loader',
  'pathing/AStarFinder'
], function (Loader, AStarFinder) {
  var Board = function (grid, finderConfig) {
    if (!grid)
      throw new Error('You must pass in a grid system for the board to use.');
    // this.pieces = []; // haven't found a use for this yet
    this.group = new THREE.Object3D();
    this.grid = null;
    this.finder = new AStarFinder(finderConfig);
    // need to keep a resource cache around, so this Loader does that, use it instead of THREE.ImageUtils
    Loader.init();
    this.setGrid(grid);
  };
  // useful enums for type checking. change to whatever fits your game. these are just examples
  Board.Cell = 'cell';
  Board.Entity = 'entity';
  // dynamic things
  Board.Structure = 'structure';
  // static things
  Board.prototype = {
    // smoothly animate a piece from its current position to the cell
    moveEntityToCell: function (entity, cell) {
    },
    // immediately snap a piece to a cell; doesn't have to be a member of the board, merely copies position
    placeEntityAtCell: function (entity, cell) {
      this.grid.cellToPixel(cell, entity.position);
      entity.position.y += entity.offsetY;
      // remove entity from old cell
      if (entity.cell) {
        entity.cell.entity = null;
      }
      // set new situation
      entity.cell = cell;
      cell.entity = entity;
    },
    findPath: function (startCell, endCell, heuristic) {
      return this.finder.findPath(startCell, endCell, heuristic, this.grid);
    },
    getRandomCell: function () {
      return this.grid.getRandomCell();
    },
    // rotate the board either left (-1, default) or right (1)
    rotate: function (direction, animate) {
      animate = animate || false;
      if (animate) {
      } else {
        this.group.rotation.y += this.grid.rotationIncrement * (direction || -1) * 2;
      }
    },
    // i think it's better to grab cells from the grid, then check the entities on them instead
    /*addPieceAt: function(entity, cell) {
    		this.pieces.push(entity);
    
    		entity.disable();
    		entity.container = this.group;
    		entity.placeEntityAtCell(entity, cell);
    	},
    
    	removePiece: function(entity) {
    		var i = this.pieces.indexOf(entity);
    		this.pieces.splice(i, 1);
    
    		entity.disable();
    	},
    
    	clear: function() {
    		this.pieces.length = 0;
    		// does not dig into children of children because they'll be removed when their parent is removed anyway
    		this.group.children.length = 0;
    	},*/
    setGrid: function (newGrid) {
      if (this.grid) {
        this.group.remove(this.grid.group);
      }
      this.grid = newGrid;
      this.group.add(newGrid.group);
    }
  };
  return Board;
});}(typeof THREE !== "undefined" ? THREE : null));
//# sourceMappingURL=hex-grid.min.js.map
